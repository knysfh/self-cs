:PROPERTIES:
:ID:       cd78ab75-eda6-42ae-a613-54a7834e7a4c
:END:
#+title: sicp-test
#+LANGUAGE: zh-CN
#+OPTIONS: toc:2 num:3 H:4 ^:nil pri:t
#+SETUPFILE: ~/Dropbox/config/comfy_inline/comfy_inline.theme
#+EXPORT_FILE_NAME: ~/Dropbox/export/sicp_test.org

# scheme version: racket 8.10-1
# use DrRacket IDE install sicp package.Detils https://docs.racket-lang.org/sicp-manual/Installation.html
# reference: https://sicp-solutions.net/;http://community.schemewiki.org/?sicp-solutions

# 1.1
10,12,8,3,6,,,19,#f,4,16,6,16

# 1.2
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

# 1.3
(define (square x) (* x x))
(define (squareSum x y) (+ (square x) (square y)))
(define (sumSquareLargestTwo x y z)
    (cond ((and (>= (+ x y) (+ y z)) (>= (+ x y) (+ x z))) (squareSum x y))
        ((and (>= (+ x y) (+ y z)) (>= (+ x z) (+ y z))) (squareSum x z))
        (else (squareSum y z))))

# 1.4
a+|b|

# 1.5
应用序先求值再应用,所以会使用重复(test 0 (p)),正则序使用形参替代先完全展开再计算结果,所以会得出正确结果0

# 1.6
由于新的new-if不再是特殊形式,即if原本满足条件时仅计算一个参数,但现在采用应用序的方式会计算两个参数,而第二个参数包括递归调用,所以会出现堆栈溢出

# 1.7
对于很大的数,在临界值检测时guess和(improve guess)两值的绝对误差很容易超出容差0.001,因此会陷入无限递归;对于很小的数,guess和(improve guess)两值的绝对误差可能开始就小于容差0.001,导致guess值不会更新.解决办法有:同比例缩放容差,比较guess和(improve guess)的相对值

# 1.8
(define (curt-iter guess x)
    (if (good-enough? guess x)
    guess
    (curt-iter (improve guess x) x)))
(define (improve guess x)
    (/ (+ (/ x (square guess)) (* 2 guess)) 3))
(define (good-enough? guess x)
    (< (abs (- (cube guess) x)) 0.001))
(define (cube x)
    (* x x x))
(define (square x)
    (* x x))

# 1.9
第一种方式：
(+ 4 5)
(inc (+ (dec 3) 5))
(inc (inc (+ (dec 2) 5)))
(inc (inc (inc (+ (dec 1) 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
第二种方式：
(+ 4 5)
(+ (dec 4) (inc 5))
(+ 3 6)
(+ (dec 3) (inc 6))
(+ 2 7)
(+ (dec 2) (inc 7))
(+ 1 8)
(+ (dec 1) (inc 8))
(+ 0 9)
9

# 1.10
1024,65536,65536
(f n)计算的是2n
(g n)计算的是2^n
(h n)计算的是2^(2^(2^..(n times)))

# 1.11
(define (fun n)
    (cond ((< n 3) n)
      (else (+ (fun (- n 1))
               (* 2 (fun (- n 2)))
               (* 3 (fun (- n 3)))))))


(define (fun n)
    (cond ((< n 3) n)
    (else (iter-fun 2 1 0 (- n 2)))))

(define (iter-fun a b c x)
    (cond ((= x 0) a)
    (else (iter-fun (+ a (* 2 b) (* 3 c)) a b (- x 1)))))

# 1.12
(define (pascal x y)
    (if (or (= y 1) (= x y))
    1
    (+ (pascal (- x 1) (- y 1)) (pascal (- x 1) y))))

# 1.13
http://community.schemewiki.org/?sicp-ex-1.13

# 1.14
#n种硬币,金额a
#space: a+n
#step: a^n

# 1.15
#a) 5
#b) log(a) 关于如何计算出Log的可以参考一下http://community.schemewiki.org/?sicp-ex-1.15

# 1.16
(define (fast-expt-iter a b n)
    (cond ((= n 1) a)
    ((even? n)
    (fast-expt-iter (square b) (square b) (/ n 2)))
    (else (* b (fast-expt-iter a b (- n 1))))))

(define (square x)
    (* x x))

# offical
(define (iter-fast-expt b n)
    (define (iter N B A)
        (cond ((= N 0) A)
        ((even? N) (iter (/ N 2) (square B) A))
        (else (iter (- N 1) B (* B A)))))
    (iter n b 1))

# 1.17
(define (double x)
    (+ x x))

(define (halve n)
    (/ n 2))

(define (* a b)
    (cond ((= b 0) 0)
        ((even? b) (double (* a (halve b))))
        (else (+ a (* a (- b 1))))))

# 1.18
(define (fast-mult-iter a b)
    (define (iter a b n)
        (cond ((= a 0) n)
            ((even? a) (iter (/ a 2) (double b) n))
            (else (iter (- a 1) b (+ b n)))))
            (iter a b 0))

# 1.19
# T_pq(a, b) = (bq + aq + ap, bp + aq), T_p'q' = T_pq(T_pq(a, b)) = ((bp + aq)q + (bq + aq + ap)q + (bq + aq + ap)p, (bp + aq)p + (bq + aq + ap)q)
# T_p'q' = (b(2qp + q^2) + a(2qp + q^2) + a(q^2 + p^2), b(p^2 + q^2) + a(2qp + q^2))
# p' = p^2 + q^2; q' = 2qp + q^2

# 1.20
# (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
# 正则序和应用序的区别,正则序先代换用到时才求值,应用序先求值再代换

# 正则序过程
(gcd 206 40)

(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))

(gcd 40 (remainder 206 40))

(if (= (remainder 206 40) 0)    # 此处第一次需要用到(remainder 206 40)的结果进行判断,其结果为6
    40
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))

(if (= 6 0)
    40
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))

(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))

(if (= (remainder 40 (remainder 206 40)) 0)     # 第二次计算(remainder 206 40)
    (remainder 206 40)
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))

(if (= (remainder 40 6) 0)     # 第三次计算(remainder 40 6)
    (remainder 206 40)
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))
    ...
共计18 times

# 应用序过程
(gcd 206 40)
(gcd 206 (gcd 40 6))
(gcd 206 (gcd 40 (gcd 6 4)))
(gcd 206 (gcd 40 (gcd 6 (gcd 4 2))))
(gcd 206 (gcd 40 (gcd 6 (gcd 4 (gcd 2 0)))))
4 times;

# 1.21
(define (smallest-divisor n)
    (find-divisor n 2))

(define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
    (= (remainder a b) 0))

(define (square a)
    (* a a))

(smallest-divisor 199)
# 199
(smallest-divisor 1999)
# 1999
(smallest-divisor 19999)
# 19999

# 1.22
(define (smallest-divisor n)
    (find-divisor n 2))

(define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
    (= (remainder a b) 0))

(define (square a)
    (* a a))

(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (prime? n)
    (= (smallest-divisor n) n))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(search-for-primes 1000 1090)
#1001 *** 3
#1003 *** 2
#1005 *** 2
(search-for-primes 10000 10090)
#10001 *** 6
#10003 *** 4
#10005 *** 3
(search-for-primes 100000 100090)
#100001 *** 10
#100003 *** 9
#100005 *** 9
(search-for-primes 1000000 100090)
#1000001 *** 35
#1000003 *** 38
#1000005 *** 32

# 1.23
(define (next n)
    (if (= n 2) 3)
        (+ n 2))

(define (smallest-divisor n)
    (find-divisor n 2))

(define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
        ((divides? (next test-divisor) n) test-divisor)
        (else (find-divisor n (next test-divisor)))))

(define (divides? a b)
    (= (remainder a b) 0))

(define (square a)
    (* a a))

(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (prime? n)
    (= (smallest-divisor n) n))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(search-for-primes 1000 1090)
#1001 *** 4
#1003 *** 1
#1005 *** 1
(search-for-primes 10000 10090)
#10001 *** 6
#10003 *** 4
#10005 *** 3
(search-for-primes 100000 100090)
#100001 *** 10
#100003 *** 9
#100005 *** 8
(search-for-primes 1000000 1000090)
#1000001 *** 37
#1000003 *** 39
#1000005 *** 26

# 1.24
(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (fast-prime? n 100)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else #f)))

(define (expmod base exp m)
    (cond ((= exp 0) 1)
        ((even? exp)
        (remainder (square (expmod base (/ exp 2) m))
            m))
        (else
            (remainder (* base (expmod base (- exp 1) m))
            m))))

(define (square n)
    (* n n))

(search-for-primes 1000 1090)
#1009 *** 85
#1013 *** 79
(search-for-primes 10000 10090)
#10007 *** 84
#10009 *** 89
(search-for-primes 100000 100090)
#100003 *** 116
(search-for-primes 1000000 1000090)
#1000003 *** 121
#1000033 *** 135

# 1.25
(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (fast-prime? n 100)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else #f)))

(define (expmod base exp m)
    (remainder (fast-expt-iter 1 base exp) m))

(define (square n)
    (* n n))

(define (fast-expt-iter a b n)
    (cond ((= n 1) a)
    ((even? n)
    (fast-expt-iter (square b) (square b) (/ n 2)))
    (else (* b (fast-expt-iter a b (- n 1))))))

(search-for-primes 1000 1090)
#1009 *** 18253

# 简单理解,求出的幂值已经超出2^63次方,所以需要使用软件进行计算,其计算速度远慢于硬件计算

# 1.26
# 由于解释器采用应用序过程,使用显式乘法后,乘法两端的(square (expmod base (/ exp 2) m))需要在应用乘法*之前就要计算出来,由于(square (expmod base (/ exp 2) m))都是递归调用,所以增加了两倍的计算量

# 1.27
# 561 1105 1729 2465 2821 6601
(define (prime-check n)
    (fast-prmie? n 100))

(define (fast-prmie? n times)
    (cond ((= times 0) #t)
        ((fermat-test n) (fast-prmie? n (- times 1)))
        (else #f)))

(define (fermat-test n)
    (define (try-it a)
        (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))

(define (expmod base exp m)
    (cond ((= exp 0) 1)
        ((even? exp) 
            (remainder (square (expmod base (/ exp 2) m)) m))
        (else 
            (remainder (* base (expmod base (- exp 1) m)) m))))

(define (square n)
    (* n n))

(prime-check 561)
#t
(prime-check 1105)
#t
(prime-check 1729)
#t
(prime-check 2465)
#t
(prime-check 2821)
#t
(prime-check 6601)
#t

# 1.28
(define (prime-check n)
    (fast-prmie? n 100))

(define (fast-prmie? n times)
    (cond ((= times 0) #t)
        ((fermat-test n) (fast-prmie? n (- times 1)))
        (else #f)))

(define (fermat-test n)
    (define (try-it a)
        (= (expmod a (- n 1) n) 1))
    (try-it (+ 1 (random (- n 1)))))

(define (check-square-root x m)
    (if (and (not (or (= x 1) (= x (- m 1)))) (= (remainder (* x x) m) 1))
    0)
    (remainder (* x x) m))

(define (expmod base exp m)
    (cond ((= exp 0) 1)
        ((even? exp)
            (check-square-root (expmod base (/ exp 2) m) m))
        (else
            (remainder (* base (expmod base (- exp 1) m)) m))))

(prime-check 2)
#t
(prime-check 1009)
#t
(prime-check 4)
#f
(prime-check 99)
#f
(prime-check 561)
#f

# 1.29
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (integral-simpson f a b n)
  (define h (/ (- b a) n))
  (define (simpson-term x)
    (+ (f x) (* 4 (f (+ x h))) (f (+ x h h))))
  (define (simpson-next x)
    (+ x (* 2 h)))
  (* (sum simpson-term a simpson-next (- b (* 2 h))) (/ h 3)))

(define (cube x)
  (* x x x))

(integral-simpson cube 0 1 100)
# 1/4
(integral-simpson cube 0 1 1000)
# 1/4

# 1.30
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))

(define (integral-simpson f a b n)
  (define h (/ (- b a) n))
  (define (simpson-term x)
    (+ (f x) (* 4 (f (+ x h))) (f (+ x h h))))
  (define (simpson-next x)
    (+ x (* 2 h)))
  (* (sum simpson-term a simpson-next (- b (* 2 h))) (/ h 3)))

(define (cube x)
  (* x x x))

(integral-simpson cube 0 1 100)
# 1/4
(integral-simpson cube 0 1 1000)
# 1/4

# 1.31
# recursion
(define (product term a next b)
  (if (> a b)
    1
    (* (term a) (product term (next a) next b))))

(define (pi-term n)
  (if (even? n)
      (/ (+ n 2) (+ n 1))
      (/ (+ n 1) (+ n 2))))

(define (pi-next n)
  (+ n 1))

(* (product pi-term 1 pi-next 100) 4.0)
#3.1570301764551676

# iteration
(define (product term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* (term a) result))))
  (iter a 1))

(define (pi-term n)
  (if (even? n)
      (/ (+ n 2) (+ n 1))
      (/ (+ n 1) (+ n 2))))

(define (pi-next n)
  (+ n 1))

(* (product pi-term 1 pi-next 100) 4.0)
#3.1570301764551676

# 1.32
# a) recursion
(define (accumulate combiner null-value term a next b)
  (if (> a b)
    null-value
    (combiner (term a) (accumulate combiner null-value term (next a) next b))))

(define (sum term a next b)
  (accumulate + 0 term a next b))

(define (product term a next b)
  (accumulate * 1 term a next b))

# b) iteration
(define (accumulate combiner null-value term a next b)
  (define (iter a res)
    (if (> a b)
        res
        (iter (next a) (combiner (res (term a))))))
  (iter a null-value))

# 1.33
# a)
# 求出在区间a到b中所有素数的平方和
(define (filtered-accumulate combiner filter null-value term a next b)
  (if (> a b)
    null-value
    (combiner (if (filter a) (term a) null-value) (filtered-accumulate combiner filter null-value term (next a) next b))))

(define (fa-next x)
  (+ x 1))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else #f)))

(define (expmod base exp m)
    (remainder (fast-expt-iter 1 base exp) m))

(define (square n)
    (* n n))

(define (fast-expt-iter a b n)
    (cond ((= n 1) a)
    ((even? n)
    (fast-expt-iter (square b) (square b) (/ n 2)))
    (else (* b (fast-expt-iter a b (- n 1))))))

(define (prime? n)
    (fast-prime? n 10))

(define (sum term a next b)
  (filtered-accumulate + prime? 0 term a next b))

(sum square 2 fa-next 20)
# 1027

# b)
(define (filter-accumulate combiner filter null-value term a next b)
  (if (> a b)
    null-value
    (combiner (if (filter a) (term a) null-value) (filter-accumulate combiner filter null-value term (next a) next b))))

(define (gcd i n)
  (if (= n 0)
    i
    (gcd n (remainder i n))))

(define (gp-term x) x)

(define (gp-next x) 
  (+ x 1))


(define (product-of-relative-prime n)
  (define (relative-prime? i)
    (= (gcd i n) 1))
  (filter-accumulate * relative-prime? 1 gp-term 1 gp-next n))

(product-of-relative-prime 10)
# 189

# 1.34
(f f) -> (f 2),但2不是一个过程

# 1.35
# 黄金分割率    Φ^2 = Φ + 1
x = 1 + 1/x ==>> x^2 = x + 1

(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (phi x)
  (+ 1 (/ 1 x)))

(fixed-point phi 1.0)
# 1.6180371352785146

# 1.36
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (phi x)
  (+ 1 (/ 1 x)))

(fixed-point phi 1.0)
# 1.0
# 2.0
# 1.5
...

# non average damping
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))


(fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0)
# 2.0
# 9.965784284662087
# 3.004472209841214
...totle 35

# average damping
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (average m n)
  (/ (+ m n) 2))


(fixed-point (lambda (x) (average x (/ (log 1000) (log x)))) 2.0)
# 2.0
# 5.9828921423310435
# 4.922168721308343
... totle 210

# 1.37
a)
(define (cont-frac n d k)
  (define (recur i)
    (if (= k i)
        (/ (n i) (d i))
        (/ (n i) (+ (d i) (recur (+ i 1))))))
  (recur 1))

(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           12)

b)
(define (cont-frac n d k)
  (define (iter i result)
    (if (= i 0)
      result
      (iter (- i 1) (/ (n i) (+ (d i) result)))))
  (iter (- k 1) (/ (n k) (d k))))

(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           12)
# 0.6180257510729613

# 1.38
(define (cont-frac n d k)
  (define (recur i)
    (if (= k i)
      (/ (n i) (d i))
      (/ (n i) (+ (d i) (recur (+ i 1))))
      ))
  (recur 1))

(+ 2 (cont-frac (lambda (i) 1.0)
  (lambda (i)
    (if (= (remainder i 3) 2)
        (/ (+ i 1) 1.5)
        1))
  10))

# 1.39
(define (cont-frac n d k)
  (define (recur i)
    (if (= k i)
      (/ (n i) (d i))
      (/ (n i) (+ (d i) (recur (+ i 1))))
      ))
  (recur 1))

(define (tan-cf x k)
  (cont-frac (lambda (i) (if (= i 1) x (* x x -1)))
             (lambda (i) (- (* 2 i) 1))
             k))

(tan-cf 1.0 8)
# 1.557407724654856

# 1.40
(define dx 0.00001)

(define (deriv g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))

(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))

(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (average m n)
  (/ (+ m n) 2))

(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))

(define (square x)
  (* x x))

(define (sqrt x)
  (newtons-method (lambda (y) (- (square y) x)) 1.0))

(sqrt 5)

(define (cubic a b c)
  (lambda (x) (+ (* x x x) (* a (* x x)) (* b x) c)))

(define a 1)
(define b 1)
(define c 1)

(newtons-method (cubic a b c) 1)
#2.2360689003143683
#-1.000000022096024

# 1.41
(define (double g)
  (lambda (x) (g (g x))))

(define (inc x)
  (+ x 1))

(((double (double double)) inc) 5)
#21

# 1.42
(define (compose f g)
  (lambda (x) (f (g x))))

(define (square x)
  (* x x))

(define (inc x)
  (+ x 1))

((compose square inc) 6)
#49

# 1.43
(define (square x) (* x x))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (repeated f n)
  (if (= n 1)
      f
      (compose f (repeated f (- n 1)))))

((repeated square 2) 5)
#625

# 1.44
(define (square x) (* x x))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (repeated f n)
  (if (= n 1)
      f
      (compose f (repeated f (- n 1)))))

(define dx 0.00001)

(define (smooth f)
  (lambda (x) (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)))

(define (n-fold-smooth f n)
  ((repeated smooth n) f))

((n-fold-smooth square 2) 6)
#36.00000000013333

# 1.45
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? next guess)
        next
        (try next))))
  (try first-guess))

(define (average-damp f)
  (lambda (x) (average x (f x))))

(define (average n m)
  (/ (+ n m) 2))

(define (repeated f n)
  (if (= n 1)
    f
    (compose f (repeated f (- n 1)))))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (power x n)
  (if (= n 1)
      x
      (* x (power x (- n 1)))))

# 多复习
(define (nth-root-damped x nth)
  (fixed-point 
     ((repeated average-damp (floor (log n 2))) 
       (lambda (y) (/ x (expt y (- n 1))))) 
     1.0))

# 1.46
(define (iterative-improve close-enough? improve)
  (lambda (guess)
    (if (close-enough? guess)
      guess
      ((iterative-improve close-enough? improve) (improve guess)))))

# sqrt
(define (sqrt-iter guess x)
  ((iterative-improve (lambda (g)  (good-enough? g x)) (lambda (g) (improve g x))) guess))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.0001))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (square x)
  (* x x))

(sqrt-iter 1.0 9)
#3.000000001396984

# fixed-point
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
  ((iterative-improve (lambda (x) (close-enough? x (f x))) 
     f) first-guess))

(fixed-point cos  1.0)
#0.7390893414033927

# 2.1
(define (numer x) (car x))
(define (denom x) (cdr x))

(define (make-rat n d)
  (let ((g ((if (< d 0) - +) (gcd n d))))
    (cons (/ n g) (/ d g))))

(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

(print-rat (make-rat 6 9))
(print-rat (make-rat -6 9))
(print-rat (make-rat 6 -9))
#2/3
#-2/3
#-2/3

# 2.2
(define (make-segment s e)
  (cons s e))

(define (start-segment x)
  (car x))

(define (end-segment x)
  (cdr x))

(define (make-point x y)
  (cons x y))

(define (x-point x)
  (car x))

(define (y-point x)
  (cdr x))

(define (midpoint-segment x)
  (define (average a b) (/ (+ a b) 2.0))
  (let ((start (start-segment x))
        (end (end-segment x)))
    (make-point (average (x-point start) (x-point end)) (average (y-point start) (y-point end)))))

(define (print-point p) 
   (newline)
   (display "(")
   (display (x-point p)) 
   (display ",")
   (display (y-point p)) 
   (display ")"))

(print-point (midpoint-segment (make-segment (make-point 2 3) (make-point 10 15))))
# (6.0,9.0)

# 2.3
#基于左下右上的两个点确定矩形
(define (make-segment s e)
  (cons s e))

(define (start-segment x)
  (car x))

(define (end-segment x)
  (cdr x))

(define (make-point x y)
  (cons x y))

(define (x-point x)
  (car x))

(define (y-point x)
  (cdr x))

(define (midpoint-segment x)
  (define (average a b) (/ (+ a b) 2.0))
  (let ((start (start-segment x))
        (end (end-segment x)))
    (make-point (average (x-point start) (x-point end)) (average (y-point start) (y-point end)))))

(define (print-point p) 
   (newline)
   (display "(")
   (display (x-point p)) 
   (display ",")
   (display (y-point p)) 
   (display ")"))

(define (compute-perimeter x)
  (let ((left-bottom-point (start-segment x))
        (right-top-point (end-segment x)))
        (* 2 (+ (- (y-point left-bottom-point) (y-point right-top-point)) (- (x-point left-bottom-point) (x-point right-top-point))))))

(compute-perimeter (make-segment (make-point 10 15) (make-point 2 3)))
#40

# 2.4
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
(define (cdr z)
  (z (lambda (p q) q)))

(cdr (cons -5 3))
#3

# 2.5
# 请证明可以只用数和算术运算表示非负整数的序对,方法是把a和b的序对表示为2^a和3^b的乘积。
# 根据基本算术定理,每个正整数都可以被分解为唯一的素数相乘序列,我们可以利用这一点,通过分解cons计算出的整数的序列,从而复原car和cdr
# 举个例子,72可以分解成72=2^3∗3^2=2∗2∗2∗3∗3,要取出car,我们就不断地进行除二操作,每次除二进行一次计数,直到不能除尽为止

(define (expt x y)
  (define (iter r n)
    (if (= n 0)
      r
      (iter (* x r) (- n 1))))
  (iter 1 y))

(define (car z)
  (if (= 0 (remainder z 2))
    (+ 1 (car (/ z 2)))
    0))

(define (cdr z)
  (if (= 0 (remainder z 3))
    (+ 1 (cdr (/ z 3)))
    0))

(define (cons a b)
  (* (expt 2 a) (expt 3 b)))

(car (cons 3 2))
(cdr (cons 3 2))
#3
#2

# 2.6
# 这道题需要将函数具象才能更好理解,建议看此教程:https://boxnos.hatenablog.com/entry/20070723/1186253252
(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))
(define (add-1 n)
  (lambda (f)
    (lambda (x)
      (f ((n f) x)))))

# 2.7
(define (add-iterval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(add-iterval (cons 6.12 7.48) (cons 5.2 4.3))
#(10.42 . 12.68)

# 2.8
#区间之差不能只用上界-上界,下界-下界,例如(1, 3) (3, 4)采用上-上,下-下会变成(2, 1)
(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))

(sub-interval (cons 2 7) (cons 8 3))
#(-6 . 4)

# 2.9
#该题查看http://community.schemewiki.org/?sicp-ex-2.9的解释

# 2.10
(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                  (max p1 p2 p3 p4))))

(define (div-interval x y)
  (if (>= 0 (* (lower-bound y) (upper-bound y)))
      (error "Division error (interval spans 0)" y)
      (mul-interval x (make-interval (/ 1.0 (lower-bound y))
                                     (/ 1.0 (upper-bound y))))))
  

(define i (make-interval 2 7))
(define j (make-interval -1 3))


(mul-interval i j)
(mul-interval j i)
(div-interval i j)
(div-interval j i)
#(-7 . 21)
#(-7 . 21)
#Division error (interval spans 0) (-1 . 3)

# 2.11
# TODO 某些语法还未学到,学习后再做

# 2.12
(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(define (make-center-percent c p)
  (let ((width (* c (/ p 100))))
    (make-interval (- c width) (+ c width))))

(define (percent i)
  (let ((center (/ (+ (upper-bound i) (lower-bound i)) 2.0))
       (width (/ (- (upper-bound i) (lower-bound i)) 2.0)))
       (* (/ width center) 100)))

(define (center x)
  (/ (+ (car x) (cdr x)) 2))

(make-center-percent (center (cons 5 10)) 20)
#(6 . 9)
(percent (make-interval 10 50))
#66.66666666666666

# 2.13
# a的区间可以表示为:(Ca表示a的中点, Ta表示a的误差)
# a = [Ca*(1 - 0.5*Ta), Ca*(1 + 0.5*Ta)]
# b的区间可以表示为:(Cb表示a的中点, Tb表示b的误差)
# b = [Cb*(1 - 0.5*Tb), Cb*(1 + 0.5*Tb)]
# a*b:
a*b = [Ca*(1 - 0.5*Ta)*Cb*(1 - 0.5*Tb), Ca*(1 + 0.5*Ta)*Cb*(1 + 0.5*Tb)]
    = [Ca*Cb*(1 - 0.5*(Ta+Tb) + 0.25TaTb), Ca*Cb*(1 + 0.5*(Ta+Tb) + 0.25TaTb)]
# Ta*Tb*0.25数值较小,可以忽略

# 2.14
#本题考查的是变量相互独立的问题,(mul-interval x y)
#函数在求解最大和最小边界时导致x和y两个区间不再互相独立,所以会导致错误结果
(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                  (max p1 p2 p3 p4))))

(define (div-interval x y)
  (if (>= 0 (* (lower-bound y) (upper-bound y)))
      (error "Division error (interval spans 0)" y)
      (mul-interval x (make-interval (/ 1.0 (lower-bound y))
                                     (/ 1.0 (upper-bound y))))))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval one (add-interval (div-interval one r1)
                                    (div-interval one r2)))))

(par1 (make-interval 3 7) (make-interval 4 6))
(par2 (make-interval 3 7) (make-interval 4 6))
#(0.9230769230769231 . 6.0)
#(1.7142857142857144 . 3.230769230769231)

# 2.15
# 说法正确,one和r1,r2互相独立

# 2.16
#代数表达式等价的前提是变量相互独立,不独立时无法保证结果的准确;
#设计新的算术包,需要从(mul-interval x y)函数下手

# 2.17
(define (last-pairs l)
  (if (null? (cdr l))
    l
    (last-pairs (cdr l))))

(last-pairs (list 23 72 149 34))
#(34)

# 2.18
(define (reverse list1)
  (define (reverse-iter listf listb)
    (if (null? listb)
        listf
        (reverse-iter (cons (car listb) listf) (cdr listb))))
  (reverse-iter (list (car list1)) (cdr list1)))

(reverse (list 1 4 9 16 25))
#(25 16 9 4 1)

# 2.19
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))

(define (no-more? c)
  (null? c))

(define (except-first-denomination c)
  (cdr c))

(define (first-denomination c)
  (car c))

(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))

(cc 100 us-coins)
#292

# 2.20
(define (append list1 list2)
  (if (null? list1)
    list2
    (cons (car list1) (append (cdr list1) list2))))

(define (same-parity a . y)
  (let ((prop (remainder a 2)))
    (define (iter target items)
      (if (null? items)
          target
          (if (= (remainder (car items) 2) prop)
              (iter (append target (list (car items))) (cdr items))
           (iter target (cdr items)))))
    (append (list a) (iter (list) y))))

(same-parity 1 2 3 4 5 6 7)
(same-parity 2 3 4 5 6 7)
#(1 3 5 7)
#(2 4 6)

# 2.21
(define (square-list items)
  (if (null? items)
    nil
    (cons (* (car items) (car items)) (square-list (cdr items)))))

(define (map proc items)
  (if (null? items)
    nil
    (cons (proc (car items)) (map proc (cdr items)))))

(define (square-list items)
  (map (lambda (x) (* x x)) items))

# 2.22
#以下代码的顺序写反了
(cons (square (car things))
  answer)

#修改后的程序实现了顺序正确的功能,但是因为第一位是nil,导致第一位元素始终为空
#((((() . 1) . 9) . 25) . 49)

# 2.23
(for-each (lambda (x) (newline) (display x))
  (list 57 321 88))

(define (for-each proc items)
  (if (null? items)
    #t
    (and (proc (car items)) (for-each proc (cdr items)))))

# 2.24

      (1 (2 (3 4)))
      /         \
      1            2
                /  \
              3     4

# 2.25
(car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9))))))
(car (car (list (list 7))))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))))))))))))

# 2.26
(define (append list1 list2)
  (if (null? list1)
    list2
    (cons (car list1) (append (cdr list1) list2))))

(define x (list 1 2 3))
(define y (list 4 5 6))
(append x y)
(cons x y)
(list x y)
#(1 2 3 4 5 6)
#((1 2 3) 4 5 6)
#((1 2 3) (4 5 6))

# 2.27
# TODO温习这道题,递归还是不太会
(define (reverse items)
  (define (rev-imp items result)
    (if (null? items)
      result
      (rev-imp (cdr items) (cons (car items) result))))
  (rev-imp items nil))


(define (deep-reverse items)
  (define (rev-imp items result)
    (if (null? items)
        result
        (let ((first (car items)))
          (rev-imp (cdr items) (cons (if (pair? first)
                                         (deep-reverse first)
                                         first)
                                     result)))))
  (rev-imp items nil))

(reverse (list 2 3 4 5))
(deep-reverse (list (list 1 2) (list 3 4)))

# 2.28
(define x (list (list 1 2) (list 3 4)))

(define (frigne items)
  (define (dis-leaves items result)
    (cond ((null? items) result)
      ((pair? items) (dis-leaves (car items) (dis-leaves (cdr items) result)))
      (else (cons items result))))
  (dis-leaves items nil))

(frigne x)
(frigne (list x x))
#(1 2 3 4)
#(1 2 3 4 1 2 3 4)

# 2.29
a)
(define (make-mobile left right)
  (list left right))

(define (make-branch length structure)
  (list length structure))

(define (left-branch movable)
  (car movable))

(define (right-branch movable)
  (car (cdr movable)))

(define l (make-branch 2 5))
(define r (make-branch 3 4))
(define b (make-mobile l r))
(left-branch b)
(right-branch b)
#(2 5)
#(3 4)

b)
# 计算总重量时需要将构造函数"make-mobile"和"make-branch"由list改为cons,因为list选择右侧分支时必要要用(cdr (cdr
(define (make-mobile left right)
  (cons left right))

(define (make-branch length structure)
  (cons length structure))

(define (left-branch movable)
  (car movable))

(define (right-branch movable)
  (cdr movable))

(define (total-weight movable)
  (cond ((null? movable) 0)
    ((not (pair? movable)) movable)
    (else (+ 
           (total-weight (cdr (left-branch movable)))
           (total-weight (cdr (right-branch movable)))))))

(define l (make-branch 2 5))
(define r (make-branch 3 4))
(define b (make-mobile l r))

(left-branch b)
(right-branch b)
(total-weight b)

c)
(define (branch-length branch)
  (car branch))

(define (branch-structure branch)
  (cdr branch))

(define (torque branch)
  (* (branch-length branch) (total-weight (branch-structure branch))))

(define (balanced? mobile)
  (if (not (pair? mobile))
      true
      (and (= (torque (left-branch mobile)) (torque (right-branch mobile)))
           (balanced? (branch-structure (left-branch mobile)))
           (balanced? (branch-structure (right-branch mobile))))))

# 2.30
(define (square-list items)
  (cond ((null? items) nil)
        ((not (pair? items)) (* items items))
        (else (cons (square-list (car items))
                    (square-list (cdr items))))))

(define (map-square-list items)
  (map (lambda (sub-items)
         (if (pair? sub-items)
             (map-square-list sub-items)
             (* sub-items sub-items)))
       items))

(define x (list 1 (list 2 (list 3 4) 5) (list 6 7)))

(square-list x)
(map-square-list x)
#(1 (4 (9 16) 25) (36 49))
#(1 (4 (9 16) 25) (36 49))

# 2.31
(define (tree-map proc tree)
  (map (lambda (sub-items)
         (if (pair? sub-items)
             (tree-map proc sub-items)
             (proc sub-items)))
       tree))

(define (square x)
  (* x x))

(define (square-tree tree)
  (tree-map square tree))

(define x (list 1 (list 2 (list 3 4) 5) (list 6 7)))
(square-tree x)

# 2.32
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x) (car (cons s x))) rest)))))

(subsets (list 1 2 3))

# 2.33
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) nil sequence))

(define (square x)
  (* x x))

(map square (list 1 2 3 4))
#(1 4 9 16)

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (append seq1 seq2)
  (accumulate cons seq2 seq1))

(append (list 1 2 3) (list 9 8 7))
#(1 2 3 9 8 7)

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))

(length (list 1 0 0 2 2 3))
#6

# 2.34
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff highter-terms) (+ this-coeff (* x highter-terms)))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 3 0 5 0 1))
#79

# 2.35
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (count-leaves t)
  (accumulate + 0 (map
                   (lambda (t) (cond ((null? t) 0)
                                      ((pair? t) (count-leaves t))
                                      (else 1))) t)))

(count-leaves '(3 2  () 1))
#3

# 2.36
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

(accumulate-n + 0 '((1 2 3) (4 5 6) (7 8 9) (10 11 12)))
#(22 26 30)

# 2.37
(define (dot-product v w)
  (accumulate + 0 (map * v w)))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(dot-product (list 1 2 3) (list 4 5 6))
#32

(define (matrix-*-vector m v)
  (map (lambda (x) (dot-product x v)) m))

(define matrix (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12)))
(matrix-*-vector matrix (list 2 3 4 5))
#(40 96 152)

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

(define (transpose mat)
  (accumulate-n cons nil mat))

(transpose matrix)
#((1 5 9) (2 6 10) (3 7 11) (4 8 12))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (dot-product v w)
  (accumulate + 0 (map * v w)))

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

(define (matrix-*-vector m v)
  (map (lambda (x) (dot-product x v)) m))

(define (transpose mat)
  (accumulate-n cons nil mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (x) (matrix-*-vector cols x)) m)))

(define matrix (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12)))
(matrix-*-matrix matrix (list (list 1 2) (list 1 2) (list 1 2) (list 1 2))) 
#((10 20) (26 52) (42 84))

# 2.38
(define (fold-right op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (fold-right op initial (cdr sequence)))))

(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))

(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
#3/2
#1/6
#(1 (2 (3 ())))
#(((() 1) 2) 3)
#op需要满足的条件是交换律和结合律

# 2.39
(define (fold-right op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (fold-right op initial (cdr sequence)))))

(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))

(define (reverse-right sequence)
  (fold-right (lambda (x y) (append y (list x))) nil sequence))

(define (reverse-left sequence)
  (fold-left (lambda (x y) (append (list y) x)) nil sequence))

(reverse-right (list 1 2 3 4 5))
(reverse-left (list 1 2 3 4 5))
#(5 4 3 2 1)
#(5 4 3 2 1)

# 2.40
(define (filter predicate sequence)
   (cond ((null? sequence) nil)
         ((predicate (car sequence))
          (cons (car sequence)
                (filter predicate (cdr sequence))))
         (else (filter predicate (cdr sequence)))))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))

(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))

# flatmap的作用可以是展开潜嵌套列表,并在展开时进行计算
# (flatmap (lambda (x) (map (lambda (y) (+ y 1)) x)) (list (list 1 2 3) (list 3 4 5)))
# (2 3 4 4 5 6)

 (define (prime? x)
   (define (test divisor)
     (cond ((> (* divisor divisor) x) true)
           ((= 0 (remainder x divisor)) false)
           (else (test (+ divisor 1)))))
   (test 2))

(define (prime-sum? pair)
   (prime? (+ (car pair) (cadr pair))))

(define (make-pair-sum pair) 
   (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)))))

(define (unique-pairs n)
   (flatmap (lambda (i)
              (map (lambda (j) (list i j))
                   (enumerate-interval 1 (- i 1))))
            (enumerate-interval 1 n)))

(define (prime-sum-pairs-new n)
   (map make-pair-sum
        (filter prime-sum? (unique-pairs n))))

(prime-sum-pairs 6)
(prime-sum-pairs-new 6)
#((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11))
#((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11))

# 2.41
#这道题的解法充分利用了递归的性质,需要反复学习
(define (filter predicate sequence)
   (cond ((null? sequence) nil)
         ((predicate (car sequence))
          (cons (car sequence)
                (filter predicate (cdr sequence))))
         (else (filter predicate (cdr sequence)))))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))

(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))

(define (ordered-triples-sum n s)
   (filter (lambda (list) (= (accumulate + 0 list) s))
          (flatmap
           (lambda (i)
             (flatmap (lambda (j)
                  (map (lambda (k) (list i j k))
                       (enumerate-interval 1 (- j 1))))
                  (enumerate-interval 1 (- i 1))))
             (enumerate-interval 1 n))))

(ordered-triples-sum 6 7)
#((4 2 1))

# 2.42
# 该题的难度在于理解每个函数的作用,flatmap函数的作用尤为重要
# flatmap的作用可以是展开潜嵌套列表,并在展开时进行计算
# (flatmap (lambda (x) (map (lambda (y) (+ y 1)) x)) (list (list 1 2 3) (list 3 4 5)))
# (2 3 4 4 5 6)

(define (adjoin-position row col rest)
   (cons (list row col) rest))

(define (check a b)
  (let ((ax (car a))
        (ay (cadr a))
        (bx (car b))
        (by (cadr b)))
    (and (not (= ax bx)) (not (= ay by))
         (not (= (abs (- ax bx)) (abs (- ay by)))))))

(define (safe? y)
  (= 0 (accumulate + 0
                   (map (lambda (x)
                          (if (check (car y) x) 0 1))
                        (cdr y)))))

(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))

(define (filter predicate sequence)
   (cond ((null? sequence) nil)
         ((predicate (car sequence))
          (cons (car sequence)
                (filter predicate (cdr sequence))))
         (else (filter predicate (cdr sequence)))))

(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list '())
        (filter
         (lambda (positions) (safe? positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
        (queen-cols board-size))

(length (queens 8))

# 2.43
# 按照Louis的写法,queen-cols会在flatmap中递归展开,导致(board-size^board-size)次运算,因此需要(8^8)T时间才能计算出结果

# 2.44
# 使用DrRacket时注意修改引入的库,由#lang sicp改为#lang racket
#lang racket
(provide (all-defined-out))
(require sicp-pict)

(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))

;; up-split also here.
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))

(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))

(paint (corner-split einstein 3))


# 2.45
(define split (beside below)
  (lambda (painter n)
    (cond ((= n 0) painter)
          (else
           (let ((smaller) ((split (beside below )) (painter (- n 1))))
             (beside painter (below smaller smaller)))))))

# 2.46
(define (make-vect x y)
  (cons x y))

(define (xcor-vect v)
  (car v))

(define (ycor-vect v)
  (cdr v))

(define (add-vect v1 v2)
  (make-vect (+ (xcor-vect v1) (xcor-vect v2))
             (+ (ycor-vect v1) (ycor-vect v2))))

(define (sub-vect v1 v2)
  (make-vect (- (xcor-vect v1) (xcor-vect v2))
             (- (ycor-vect v1) (ycor-vect v2))))

(define (scale s v)
  (make-vect (* s (xcor-vect v))
             (* s (ycor-vect v))))

# 2.47
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
(define (frame-origin f) (car f))
(define (frame-edge1 f) (cadr f))
(define (frame-edge2 f) (caddr f))

(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
(define (frame-origin f) (car f))
(define (frame-edge1 f) (cadr f))
(define (frame-edge2 f) (cddr f))

# 2.48
(define (make-vect x y)
  (list x y))
(define (make-segment start end)
  (list start end))
(define (start-segment segment)
  (car segment))
(define (end-segment segment)
  (cadr segment))

# 2.49
#lang sicp
(#%require sicp-pict) 

;; 2.49a
(define outline
  (segments->painter
   (list
    (segment (vect 0.0 0.0) (vect 0.0 1.0))
    (segment (vect 0.0 0.0) (vect 1.0 0.0))
    (segment (vect 0.0 1.0) (vect 1.0 1.0))
    (segment (vect 1.0 0.0) (vect 1.0 1.0)))))
(paint outline)
;; 2.49b
(define x-painter
  (segments->painter
   (list
    (segment (vect 0.0 0.0) (vect 1.0 1.0))
    (segment (vect 0.0 1.0) (vect 1.0 0.0)))))
(paint x-painter)
;; 2.49c
(define diamond
  (segments->painter
   (list
    (segment (vect 0.5 0.0) (vect 0.0 0.5))
    (segment (vect 0.0 0.5) (vect 0.5 1.0))
    (segment (vect 0.5 1.0) (vect 1.0 0.5))
    (segment (vect 1.0 0.5) (vect 0.5 0.0)))))
(paint diamond)
;; 2.49d
(define x 1.5)
(define y 1.8)

(define (normalize coords)
  (let ((x1 (car coords))
        (y1 (cadr coords))
        (x2 (caddr coords))
        (y2 (cadddr coords)))
    (list (/ x1 x) (/ y1 y) (/ x2 x) (/ y2 y))))

(define (mirror coords)
  (list (- x (car coords)) (cadr coords) (- x (caddr coords)) (cadddr coords)))

(define (list->line coords)
  (let ((x1 (car coords))
        (y1 (cadr coords))
        (x2 (caddr coords))
        (y2 (cadddr coords)))
    (segment (vect x1 y1) (vect x2 y2))))

(define wave-coords
  (list
   (list 0.5 1.5 0.65 y)
   (mirror (list 0.5 1.5 0.65 y))
   (list 0.5 1.5 0.65 1.2)
   (mirror (list 0.5 1.5 0.65 1.2))
   (list 0.5 1.22 0.65 1.2)
   (mirror (list 0.5 1.22 0.65 1.2))
   (list 0.5 1.22 0.3 1.05)
   (mirror (list 0.5 1.22 0.3 1.05))
   (list 0.3 1.05 0.0 1.35)
   (list (- x 0.3) 1.05 x 0.65)
   (list 0.4 0 0.55 1)
   (mirror (list 0.4 0 0.55 1))
   (list 0.55 1 0.25 0.85)
   (mirror (list 0.4 0 0.55 1))
   (list 0.25 0.85 0 1.15)
   (list (- x 0.55) 1 x 0.5)
   (list 0.6 0 0.7 0.5)
   (mirror (list 0.6 0 0.7 0.5))
   (list 0.7 0.5 (/ x 2) 0.58)
   (mirror (list 0.7 0.5 (/ x 2) 0.58))))

(define wave
  (segments->painter
   (map list->line (map normalize wave-coords))))
(paint wave)

# 2.50
# 2.51
# 2.52
# TODO先跳过框架这一节,未来补充

# 2.53
(list 'a 'b 'c)
(list (list 'george))
(cdr '((x1 x2) (y1 y2)))
(cadr '((x1 x2) (y1 y2)))
(pair? (car '(a short list)))
(memq 'red '((red shoes) (blue socks)))
(memq 'red '(red shoes blue socks))

(a b c)
((george))
((y1 y2))
(y1 y2)
#f
#f
(red shoes blue socks)

# 2.54
(define (equal? x y)
  (cond ((and (not (pair? x)) (not (pair? y)))
         (eq? x y))
        ((and (pair? x) (pair? y))
         (and (equal? (car x) (car y)) (equal? (cdr x) (cdr y))))
        (else #f)))

(equal? '(this is a list) '(this is a list))
(equal? '(this is a list) '(this (is a) list))

#t
#f

# 2.55
#quote表示引用, ''a 表示的列表中有两个元素分别是 (quote a),所以(car ''a)会返回quote

# 2.56
(define (variable? x) (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))

(define (addend s) (cadr s))

(define (augend s) (caddr s))

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))

(define (multiplier p) (cadr p))

(define (multiplicand p) (caddr p))

(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))

(define (base p) (cadr p))

(define (exponent p) (caddr p))

(define (make-exponentiation n1 n2)
  (cond ((=number? n1 1) 1)
         ((=number? n2 1) n1)
         ((=number? n2 0) 1)
         (else (list '** n1 n2))))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentiation? exp)
         (make-product 
          (make-product (exponent exp)
                        (make-exponentiation (base exp)
                                             (if (number? (exponent exp))
                                                 (- (exponent exp) 1)
                                                 (' (- (exponent exp) 1)))))
          (deriv (base exp) var)))
        (else
         (error "unknow expression type -- DERIV" exp))))

(deriv '(** x 3) 'x)

# (* 3 (** x 2))

# 2.57
(define (variable? x) (symbol? x))

(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))

(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))

(define (=number? exp num)
  (and (number? exp) (= exp num)))

(define (sum? x)
  (and (pair? x) (eq? (car x) '+)))

(define (addend s) (cadr s))

;;(define (augend s) (caddr s))

(define (product? x)
  (and (pair? x) (eq? (car x) '*)))

(define (multiplier p) (cadr p))

;;(define (multiplicand p) (caddr p))

(define (exponentiation? x)
  (and (pair? x) (eq? (car x) '**)))

(define (base p) (cadr p))

(define (exponent p) (caddr p))

(define (make-exponentiation n1 n2)
  (cond ((=number? n1 1) 1)
         ((=number? n2 1) n1)
         ((=number? n2 0) 1)
         (else (list '** n1 n2))))

(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        ((exponentiation? exp)
         (make-product 
          (make-product (exponent exp)
                        (make-exponentiation (base exp)
                                             (if (number? (exponent exp))
                                                 (- (exponent exp) 1)
                                                 (' (- (exponent exp) 1)))))
          (deriv (base exp) var)))
        (else
         (error "unknow expression type -- DERIV" exp))))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (augend s)
  (accumulate make-sum 0 (cddr s)))

(define (multiplicand p)
  (accumulate make-product 1 (cddr  p)))

(deriv '(* x y (+ x 3)) 'x)
# 本题的思路就是将多项式分解为两两组合的形式,即 (* x y (+ x 3)) -> (* (* x y) (+ x 3)),满足两两组合的形式就可以用原来的deriv方法

# 2.58
# 借助堆栈将中缀改为前缀,再套用原来的函数,能够有更好的扩展性

# 2.59
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

(define (union-set s1 s2)
  (if (null? s1)
      s2
      (let
          ((e (car s1)))
        (union-set
         (cdr s1)
         (if (element-of-set? e s2) s2 (cons e s2))))))

(define (intersection-set s1 s2)
  (cond ((or (null? s1) (null? s2)) '())
        ((element-of-set? (car s1) s2)
         (cons (car s1)
               (intersection-set (cdr s1) s2)))
        (else (intersection-set (cdr s1) s2))))

(union-set '(1 3 5) '(2 4 5 6))
(intersection-set '(1 3 5) '(2 4 5 6))
# (3 1 2 4 5 6)
# (5)

# 2.60
# 修改后union-set和adjoin-set函数变为O(1)操作,在求交集和拼接集合操作频繁且不关注是否重复的应用中可以采用这样的表示
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((equal? x (car set)) true)
        (else (element-of-set? x (cdr set)))))

(define (adjoin-set x set)
      (cons x set))

(define (union-set s1 s2)
  (append s1 s2))

(define (intersection-set s1 s2)
  (cond ((or (null? s1) (null? s2)) '())
        ((element-of-set? (car s1) s2)
         (cons (car s1)
               (intersection-set (cdr s1) s2)))
        (else (intersection-set (cdr s1) s2))))

(union-set '(1 3 7 5) '(2 4 5 6))
(intersection-set '(1 3 2 5 5) '(2 4 5 6))
# (1 3 7 5 2 4 5 6)
# (2 5 5)

# 2.61
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((> x (car set)) (cons (car set) (adjoin-set x (cdr set))))
        ((< x (car set)) (cons x set))
        (else set)))

#(adjoin-set 3 '())
#(adjoin-set 3 '(1 2 4 5))
#(adjoin-set 3 '(1 2 3 4))
#(3)
#(1 2 3 4 5)
#(1 2 3 4)

# 2.62
(define (union-set s1 s2)
  (cond ((null? s1) s2)
        ((null? s2) s1)
        ((> (car s1) (car s2)) (cons (car s2) (union-set s1 (cdr s2))))
        ((= (car s1) (car s2)) (cons (car s1) (union-set (cdr s1) (cdr s2))))
        (else (cons (car s1) (union-set (cdr s1) s2)))))

(union-set '(1 3 4) '(2 3 5))

# 2.63
a)
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))

(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) (element-of-set? x (left-branch set)))
        ((> x (car set)) (element-of-set? x (right-branch set)))))

(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree)
                                          result-list)))))
    (copy-to-list tree '()))

(define fig2-16-1 '(7 (3 (1 () ()) (5 () ())) (9 () (11 () ()))))
(define fig2-16-2 '(3 (1 () ()) (7 (5 () ()) (9 () (11 () ())))))
(define fig2-16-3 '(5 (3 (1 () ()) ()) (9 (7 () ()) (11 () ()))))
(tree->list-1 fig2-16-1)
(tree->list-2 fig2-16-1)
(tree->list-1 fig2-16-2)
(tree->list-2 fig2-16-2)
(tree->list-1 fig2-16-3)
(tree->list-2 fig2-16-3)
(1 3 5 7 9 11)
(1 3 5 7 9 11)
(1 3 5 7 9 11)
(1 3 5 7 9 11)
(1 3 5 7 9 11)
(1 3 5 7 9 11)

b)
tree->list-1展开
(append 
 (append (append '() (cons 1 '())) (cons 3 (append '() (cons 5 '()))))
 (cons 7 (append '() (cons 9 (append '() (cons 11 '()))))))

tree->list-2展开
(cons 1 (cons 3 (cons 5 (cons 7 (cons 9 (cons 11 '()))))))

#两种方法都需要遍历一次树,但不清楚append和cons的实现机制,但总体tree->list-1的步骤更多一些

# 2.64
# http://community.schemewiki.org/?sicp-ex-2.64
# TODO partial-tree递归有点绕

# 2.65
# intersection-set与union-set操作类似
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))

(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (car set)) true)
        ((< x (car set)) (element-of-set? x (left-branch set)))
        ((> x (car set)) (element-of-set? x (right-branch set)))))

(define (list->tree elements)
  (car (partial-tree elements (length elements))))

(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts)
                                              right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry left-tree right-tree)
                      remaining-elts))))))))

(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(define (union-set s1 s2)
  (cond ((null? s1) s2)
        ((null? s2) s1)
        ((> (car s1) (car s2)) (cons (car s2) (union-set s1 (cdr s2))))
        ((= (car s1) (car s2)) (cons (car s1) (union-set (cdr s1) (cdr s2))))
        (else (cons (car s1) (union-set (cdr s1) s2)))))

(define (union-set-265 s t)
  (cond ((null? s) t)
        ((null? t) s)
        (else (list->tree (union-set (tree->list-1 s) (tree->list-1 t))))))

(union-set-265 (list->tree '(1 2 4 5 6)) (list->tree '(1 3 4 5 7)))
#(4 (2 (1 () ()) (3 () ())) (6 (5 () ()) (7 () ())))


# 2.66
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree key value left right)
  (list '(key value) left right))
(define (key n)
  (car n))

(define (value n)
  (cdr n))

(define (lookup1 given-key set-of-records)
  (cond ((null? set-of-records) false)
        ((= given-key (key (entry set-of-records)))
         (value (entry set-of-records)))
        ((> given-key (key (entry set-of-records)))
         (lookup1 given-key (right-branch set-of-records)))
        (else (lookup1 given-key (left-branch set-of-records)))))

(define tmp-set '((7 0) ((3 10) ((1 18) () ()) ((5 117) () ())) ((9 20) () ((11 14) () ()))))

(lookup1 5 tmp-set)
#(117)

# 2.67
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))

(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))

(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))

(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit -- CHOOSE-BRANCH" bit))))

(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))

(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
(decode sample-message sample-tree)
# (A D A B B C A)

# 2.68
#lang sicp
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))

(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))

(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))

(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch
               (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit -- CHOOSE-BRANCH" bit))))

(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree
                   (make-leaf 'B 2)
                   (make-code-tree (make-leaf 'D 1)
                                   (make-leaf 'C 1)))))

(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))

(define (encode-symbol sym tree)
  (if (leaf? tree)
      (if (eq? sym (symbol-leaf tree))
          '()
          (error "missing symbol: ENCODE-SYMBOL" sym))
      (let ((left (left-branch tree)))
        (if (memq sym (symbols left))
            (cons 0 (encode-symbol sym left))
            (cons 1 (encode-symbol sym (right-branch tree)))))))

(encode '(A D A B B C A) sample-tree)
#(0 1 1 0 0 1 0 1 0 1 1 1 0)

# 2.69
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))

(define (leaf? object)
  (eq? (car object) 'leaf))

(define (symbol-leaf x) (cadr x))

(define (weight-leaf x) (caddr x))

(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))

(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))))

(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))

(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))

(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)
                               (cadr pair))
                    (make-leaf-set (cdr pairs))))))

(define one-set (make-leaf-set '((A 4) (B 2) (C 6) (D 10))))

(define (successive-merge set)
  (cond  ((null? set) '())
         ((null? (cdr set)) (car set))
         (else
          (successive-merge (cddr
                             (adjoin-set
                              (make-code-tree (car set) (cadr set))
                              set))))))

(successive-merge one-set)
# ((leaf D 10) ((leaf C 6) ((leaf B 2) (leaf A 4) (B A) 6) (C B A) 12) (D C B A) 22)