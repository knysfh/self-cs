:PROPERTIES:
:ID:       cd78ab75-eda6-42ae-a613-54a7834e7a4c
:END:
#+title: sicp-test
#+LANGUAGE: zh-CN
#+OPTIONS: toc:2 num:3 H:4 ^:nil pri:t
#+SETUPFILE: ~/Dropbox/config/comfy_inline/comfy_inline.theme
#+EXPORT_FILE_NAME: ~/Dropbox/export/sicp_test.org

# scheme version: racket 8.10-1
# use DrRacket IDE install sicp package.Detils https://docs.racket-lang.org/sicp-manual/Installation.html
# reference: https://sicp-solutions.net/;http://community.schemewiki.org/?sicp-solutions

# 1.1
10,12,8,3,6,,,19,#f,4,16,6,16

# 1.2
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

# 1.3
(define (square x) (* x x))
(define (squareSum x y) (+ (square x) (square y)))
(define (sumSquareLargestTwo x y z)
    (cond ((and (>= (+ x y) (+ y z)) (>= (+ x y) (+ x z))) (squareSum x y))
        ((and (>= (+ x y) (+ y z)) (>= (+ x z) (+ y z))) (squareSum x z))
        (else (squareSum y z))))

# 1.4
a+|b|

# 1.5
应用序先求值再应用,所以会使用重复(test 0 (p)),正则序使用形参替代先完全展开再计算结果,所以会得出正确结果0

# 1.6
由于新的new-if不再是特殊形式,即if原本满足条件时仅计算一个参数,但现在采用应用序的方式会计算两个参数,而第二个参数包括递归调用,所以会出现堆栈溢出

# 1.7
对于很大的数,在临界值检测时guess和(improve guess)两值的绝对误差很容易超出容差0.001,因此会陷入无限递归;对于很小的数,guess和(improve guess)两值的绝对误差可能开始就小于容差0.001,导致guess值不会更新.解决办法有:同比例缩放容差,比较guess和(improve guess)的相对值

# 1.8
(define (curt-iter guess x)
    (if (good-enough? guess x)
    guess
    (curt-iter (improve guess x) x)))
(define (improve guess x)
    (/ (+ (/ x (square guess)) (* 2 guess)) 3))
(define (good-enough? guess x)
    (< (abs (- (cube guess) x)) 0.001))
(define (cube x)
    (* x x x))
(define (square x)
    (* x x))

# 1.9
第一种方式：
(+ 4 5)
(inc (+ (dec 3) 5))
(inc (inc (+ (dec 2) 5)))
(inc (inc (inc (+ (dec 1) 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
第二种方式：
(+ 4 5)
(+ (dec 4) (inc 5))
(+ 3 6)
(+ (dec 3) (inc 6))
(+ 2 7)
(+ (dec 2) (inc 7))
(+ 1 8)
(+ (dec 1) (inc 8))
(+ 0 9)
9

# 1.10
1024,65536,65536
(f n)计算的是2n
(g n)计算的是2^n
(h n)计算的是2^(2^(2^..(n times)))

# 1.11
(define (fun n)
    (cond ((< n 3) n)
      (else (+ (fun (- n 1))
               (* 2 (fun (- n 2)))
               (* 3 (fun (- n 3)))))))


(define (fun n)
    (cond ((< n 3) n)
    (else (iter-fun 2 1 0 (- n 2)))))

(define (iter-fun a b c x)
    (cond ((= x 0) a)
    (else (iter-fun (+ a (* 2 b) (* 3 c)) a b (- x 1)))))

# 1.12
(define (pascal x y)
    (if (or (= y 1) (= x y))
    1
    (+ (pascal (- x 1) (- y 1)) (pascal (- x 1) y))))

# 1.13
http://community.schemewiki.org/?sicp-ex-1.13

# 1.14
#n种硬币,金额a
#space: a+n
#step: a^n

# 1.15
#a) 5
#b) log(a) 关于如何计算出Log的可以参考一下http://community.schemewiki.org/?sicp-ex-1.15

# 1.16
(define (fast-expt-iter a b n)
    (cond ((= n 1) a)
    ((even? n)
    (fast-expt-iter (square b) (square b) (/ n 2)))
    (else (* b (fast-expt-iter a b (- n 1))))))

(define (square x)
    (* x x))

# offical
(define (iter-fast-expt b n)
    (define (iter N B A)
        (cond ((= N 0) A)
        ((even? N) (iter (/ N 2) (square B) A))
        (else (iter (- N 1) B (* B A)))))
    (iter n b 1))

# 1.17
(define (double x)
    (+ x x))

(define (halve n)
    (/ n 2))

(define (* a b)
    (cond ((= b 0) 0)
        ((even? b) (double (* a (halve b))))
        (else (+ a (* a (- b 1))))))

# 1.18
(define (fast-mult-iter a b)
    (define (iter a b n)
        (cond ((= a 0) n)
            ((even? a) (iter (/ a 2) (double b) n))
            (else (iter (- a 1) b (+ b n)))))
            (iter a b 0))

# 1.19
# T_pq(a, b) = (bq + aq + ap, bp + aq), T_p'q' = T_pq(T_pq(a, b)) = ((bp + aq)q + (bq + aq + ap)q + (bq + aq + ap)p, (bp + aq)p + (bq + aq + ap)q)
# T_p'q' = (b(2qp + q^2) + a(2qp + q^2) + a(q^2 + p^2), b(p^2 + q^2) + a(2qp + q^2))
# p' = p^2 + q^2; q' = 2qp + q^2

# 1.20
# (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
# 正则序和应用序的区别,正则序先代换用到时才求值,应用序先求值再代换

# 正则序过程
(gcd 206 40)

(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))

(gcd 40 (remainder 206 40))

(if (= (remainder 206 40) 0)    # 此处第一次需要用到(remainder 206 40)的结果进行判断,其结果为6
    40
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))

(if (= 6 0)
    40
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))

(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))

(if (= (remainder 40 (remainder 206 40)) 0)     # 第二次计算(remainder 206 40)
    (remainder 206 40)
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))

(if (= (remainder 40 6) 0)     # 第三次计算(remainder 40 6)
    (remainder 206 40)
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))
    ...
共计18 times

# 应用序过程
(gcd 206 40)
(gcd 206 (gcd 40 6))
(gcd 206 (gcd 40 (gcd 6 4)))
(gcd 206 (gcd 40 (gcd 6 (gcd 4 2))))
(gcd 206 (gcd 40 (gcd 6 (gcd 4 (gcd 2 0)))))
4 times;

# 1.21
(define (smallest-divisor n)
    (find-divisor n 2))

(define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
    (= (remainder a b) 0))

(define (square a)
    (* a a))

(smallest-divisor 199)
# 199
(smallest-divisor 1999)
# 1999
(smallest-divisor 19999)
# 19999

# 1.22
(define (smallest-divisor n)
    (find-divisor n 2))

(define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
    (= (remainder a b) 0))

(define (square a)
    (* a a))

(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (prime? n)
    (= (smallest-divisor n) n))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(search-for-primes 1000 1090)
#1001 *** 3
#1003 *** 2
#1005 *** 2
(search-for-primes 10000 10090)
#10001 *** 6
#10003 *** 4
#10005 *** 3
(search-for-primes 100000 100090)
#100001 *** 10
#100003 *** 9
#100005 *** 9
(search-for-primes 1000000 100090)
#1000001 *** 35
#1000003 *** 38
#1000005 *** 32

# 1.23
(define (next n)
    (if (= n 2) 3)
        (+ n 2))

(define (smallest-divisor n)
    (find-divisor n 2))

(define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
        ((divides? (next test-divisor) n) test-divisor)
        (else (find-divisor n (next test-divisor)))))

(define (divides? a b)
    (= (remainder a b) 0))

(define (square a)
    (* a a))

(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (prime? n)
    (= (smallest-divisor n) n))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(search-for-primes 1000 1090)
#1001 *** 4
#1003 *** 1
#1005 *** 1
(search-for-primes 10000 10090)
#10001 *** 6
#10003 *** 4
#10005 *** 3
(search-for-primes 100000 100090)
#100001 *** 10
#100003 *** 9
#100005 *** 8
(search-for-primes 1000000 1000090)
#1000001 *** 37
#1000003 *** 39
#1000005 *** 26

# 1.24
(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (fast-prime? n 100)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else #f)))

(define (expmod base exp m)
    (cond ((= exp 0) 1)
        ((even? exp)
        (remainder (square (expmod base (/ exp 2) m))
            m))
        (else
            (remainder (* base (expmod base (- exp 1) m))
            m))))

(define (square n)
    (* n n))

(search-for-primes 1000 1090)
#1009 *** 85
#1013 *** 79
(search-for-primes 10000 10090)
#10007 *** 84
#10009 *** 89
(search-for-primes 100000 100090)
#100003 *** 116
(search-for-primes 1000000 1000090)
#1000003 *** 121
#1000033 *** 135

# 1.25
(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (fast-prime? n 100)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else #f)))

(define (expmod base exp m)
    (remainder (fast-expt-iter 1 base exp) m))

(define (square n)
    (* n n))

(define (fast-expt-iter a b n)
    (cond ((= n 1) a)
    ((even? n)
    (fast-expt-iter (square b) (square b) (/ n 2)))
    (else (* b (fast-expt-iter a b (- n 1))))))

(search-for-primes 1000 1090)
#1009 *** 18253

# 简单理解,求出的幂值已经超出2^63次方,所以需要使用软件进行计算,其计算速度远慢于硬件计算

# 1.26
# 由于解释器采用应用序过程,使用显式乘法后,乘法两端的(square (expmod base (/ exp 2) m))需要在应用乘法*之前就要计算出来,由于(square (expmod base (/ exp 2) m))都是递归调用,所以增加了两倍的计算量

# 1.27
# 561 1105 1729 2465 2821 6601
(define (prime-check n)
    (fast-prmie? n 100))

(define (fast-prmie? n times)
    (cond ((= times 0) #t)
        ((fermat-test n) (fast-prmie? n (- times 1)))
        (else #f)))

(define (fermat-test n)
    (define (try-it a)
        (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))

(define (expmod base exp m)
    (cond ((= exp 0) 1)
        ((even? exp) 
            (remainder (square (expmod base (/ exp 2) m)) m))
        (else 
            (remainder (* base (expmod base (- exp 1) m)) m))))

(define (square n)
    (* n n))

(prime-check 561)
#t
(prime-check 1105)
#t
(prime-check 1729)
#t
(prime-check 2465)
#t
(prime-check 2821)
#t
(prime-check 6601)
#t

# 1.28
(define (prime-check n)
    (fast-prmie? n 100))

(define (fast-prmie? n times)
    (cond ((= times 0) #t)
        ((fermat-test n) (fast-prmie? n (- times 1)))
        (else #f)))

(define (fermat-test n)
    (define (try-it a)
        (= (expmod a (- n 1) n) 1))
    (try-it (+ 1 (random (- n 1)))))

(define (check-square-root x m)
    (if (and (not (or (= x 1) (= x (- m 1)))) (= (remainder (* x x) m) 1))
    0)
    (remainder (* x x) m))

(define (expmod base exp m)
    (cond ((= exp 0) 1)
        ((even? exp)
            (check-square-root (expmod base (/ exp 2) m) m))
        (else
            (remainder (* base (expmod base (- exp 1) m)) m))))

(prime-check 2)
#t
(prime-check 1009)
#t
(prime-check 4)
#f
(prime-check 99)
#f
(prime-check 561)
#f

# 1.29
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (integral-simpson f a b n)
  (define h (/ (- b a) n))
  (define (simpson-term x)
    (+ (f x) (* 4 (f (+ x h))) (f (+ x h h))))
  (define (simpson-next x)
    (+ x (* 2 h)))
  (* (sum simpson-term a simpson-next (- b (* 2 h))) (/ h 3)))

(define (cube x)
  (* x x x))

(integral-simpson cube 0 1 100)
# 1/4
(integral-simpson cube 0 1 1000)
# 1/4

# 1.30
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))

(define (integral-simpson f a b n)
  (define h (/ (- b a) n))
  (define (simpson-term x)
    (+ (f x) (* 4 (f (+ x h))) (f (+ x h h))))
  (define (simpson-next x)
    (+ x (* 2 h)))
  (* (sum simpson-term a simpson-next (- b (* 2 h))) (/ h 3)))

(define (cube x)
  (* x x x))

(integral-simpson cube 0 1 100)
# 1/4
(integral-simpson cube 0 1 1000)
# 1/4

# 1.31
# recursion
(define (product term a next b)
  (if (> a b)
    1
    (* (term a) (product term (next a) next b))))

(define (pi-term n)
  (if (even? n)
      (/ (+ n 2) (+ n 1))
      (/ (+ n 1) (+ n 2))))

(define (pi-next n)
  (+ n 1))

(* (product pi-term 1 pi-next 100) 4.0)
#3.1570301764551676

# iteration
(define (product term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* (term a) result))))
  (iter a 1))

(define (pi-term n)
  (if (even? n)
      (/ (+ n 2) (+ n 1))
      (/ (+ n 1) (+ n 2))))

(define (pi-next n)
  (+ n 1))

(* (product pi-term 1 pi-next 100) 4.0)
#3.1570301764551676

# 1.32
# a) recursion
(define (accumulate combiner null-value term a next b)
  (if (> a b)
    null-value
    (combiner (term a) (accumulate combiner null-value term (next a) next b))))

(define (sum term a next b)
  (accumulate + 0 term a next b))

(define (product term a next b)
  (accumulate * 1 term a next b))

# b) iteration
(define (accumulate combiner null-value term a next b)
  (define (iter a res)
    (if (> a b)
        res
        (iter (next a) (combiner (res (term a))))))
  (iter a null-value))

# 1.33
# a)
# 求出在区间a到b中所有素数的平方和
(define (filtered-accumulate combiner filter null-value term a next b)
  (if (> a b)
    null-value
    (combiner (if (filter a) (term a) null-value) (filtered-accumulate combiner filter null-value term (next a) next b))))

(define (fa-next x)
  (+ x 1))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else #f)))

(define (expmod base exp m)
    (remainder (fast-expt-iter 1 base exp) m))

(define (square n)
    (* n n))

(define (fast-expt-iter a b n)
    (cond ((= n 1) a)
    ((even? n)
    (fast-expt-iter (square b) (square b) (/ n 2)))
    (else (* b (fast-expt-iter a b (- n 1))))))

(define (prime? n)
    (fast-prime? n 10))

(define (sum term a next b)
  (filtered-accumulate + prime? 0 term a next b))

(sum square 2 fa-next 20)
# 1027

# b)
(define (filter-accumulate combiner filter null-value term a next b)
  (if (> a b)
    null-value
    (combiner (if (filter a) (term a) null-value) (filter-accumulate combiner filter null-value term (next a) next b))))

(define (gcd i n)
  (if (= n 0)
    i
    (gcd n (remainder i n))))

(define (gp-term x) x)

(define (gp-next x) 
  (+ x 1))


(define (product-of-relative-prime n)
  (define (relative-prime? i)
    (= (gcd i n) 1))
  (filter-accumulate * relative-prime? 1 gp-term 1 gp-next n))

(product-of-relative-prime 10)
# 189

# 1.34
(f f) -> (f 2),但2不是一个过程

# 1.35
# 黄金分割率    Φ^2 = Φ + 1
x = 1 + 1/x ==>> x^2 = x + 1

(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (phi x)
  (+ 1 (/ 1 x)))

(fixed-point phi 1.0)
# 1.6180371352785146

# 1.36
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (phi x)
  (+ 1 (/ 1 x)))

(fixed-point phi 1.0)
# 1.0
# 2.0
# 1.5
...

# non average damping
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))


(fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0)
# 2.0
# 9.965784284662087
# 3.004472209841214
...totle 35

# average damping
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (average m n)
  (/ (+ m n) 2))


(fixed-point (lambda (x) (average x (/ (log 1000) (log x)))) 2.0)
# 2.0
# 5.9828921423310435
# 4.922168721308343
... totle 210

# 1.37
a)
(define (cont-frac n d k)
  (define (recur i)
    (if (= k i)
        (/ (n i) (d i))
        (/ (n i) (+ (d i) (recur (+ i 1))))))
  (recur 1))

(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           12)

b)
(define (cont-frac n d k)
  (define (iter i result)
    (if (= i 0)
      result
      (iter (- i 1) (/ (n i) (+ (d i) result)))))
  (iter (- k 1) (/ (n k) (d k))))

(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           12)
# 0.6180257510729613

# 1.38
(define (cont-frac n d k)
  (define (recur i)
    (if (= k i)
      (/ (n i) (d i))
      (/ (n i) (+ (d i) (recur (+ i 1))))
      ))
  (recur 1))

(+ 2 (cont-frac (lambda (i) 1.0)
  (lambda (i)
    (if (= (remainder i 3) 2)
        (/ (+ i 1) 1.5)
        1))
  10))

# 1.39
(define (cont-frac n d k)
  (define (recur i)
    (if (= k i)
      (/ (n i) (d i))
      (/ (n i) (+ (d i) (recur (+ i 1))))
      ))
  (recur 1))

(define (tan-cf x k)
  (cont-frac (lambda (i) (if (= i 1) x (* x x -1)))
             (lambda (i) (- (* 2 i) 1))
             k))

(tan-cf 1.0 8)
# 1.557407724654856

# 1.40
(define dx 0.00001)

(define (deriv g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))

(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))

(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (average m n)
  (/ (+ m n) 2))

(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))

(define (square x)
  (* x x))

(define (sqrt x)
  (newtons-method (lambda (y) (- (square y) x)) 1.0))

(sqrt 5)

(define (cubic a b c)
  (lambda (x) (+ (* x x x) (* a (* x x)) (* b x) c)))

(define a 1)
(define b 1)
(define c 1)

(newtons-method (cubic a b c) 1)
#2.2360689003143683
#-1.000000022096024

# 1.41
(define (double g)
  (lambda (x) (g (g x))))

(define (inc x)
  (+ x 1))

(((double (double double)) inc) 5)
#21

# 1.42
(define (compose f g)
  (lambda (x) (f (g x))))

(define (square x)
  (* x x))

(define (inc x)
  (+ x 1))

((compose square inc) 6)
#49

# 1.43
(define (square x) (* x x))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (repeated f n)
  (if (= n 1)
      f
      (compose f (repeated f (- n 1)))))

((repeated square 2) 5)
#625

# 1.44
(define (square x) (* x x))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (repeated f n)
  (if (= n 1)
      f
      (compose f (repeated f (- n 1)))))

(define dx 0.00001)

(define (smooth f)
  (lambda (x) (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)))

(define (n-fold-smooth f n)
  ((repeated smooth n) f))

((n-fold-smooth square 2) 6)
#36.00000000013333

# 1.45
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? next guess)
        next
        (try next))))
  (try first-guess))

(define (average-damp f)
  (lambda (x) (average x (f x))))

(define (average n m)
  (/ (+ n m) 2))

(define (repeated f n)
  (if (= n 1)
    f
    (compose f (repeated f (- n 1)))))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (power x n)
  (if (= n 1)
      x
      (* x (power x (- n 1)))))

# 多复习
(define (nth-root-damped x nth)
  (fixed-point 
     ((repeated average-damp (floor (log n 2))) 
       (lambda (y) (/ x (expt y (- n 1))))) 
     1.0))

# 1.46
(define (iterative-improve close-enough? improve)
  (lambda (guess)
    (if (close-enough? guess)
      guess
      ((iterative-improve close-enough? improve) (improve guess)))))

# sqrt
(define (sqrt-iter guess x)
  ((iterative-improve (lambda (g)  (good-enough? g x)) (lambda (g) (improve g x))) guess))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.0001))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (square x)
  (* x x))

(sqrt-iter 1.0 9)
#3.000000001396984

# fixed-point
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
  ((iterative-improve (lambda (x) (close-enough? x (f x))) 
     f) first-guess))

(fixed-point cos  1.0)
#0.7390893414033927

# 2.1
(define (numer x) (car x))
(define (denom x) (cdr x))

(define (make-rat n d)
  (let ((g ((if (< d 0) - +) (gcd n d))))
    (cons (/ n g) (/ d g))))

(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

(print-rat (make-rat 6 9))
(print-rat (make-rat -6 9))
(print-rat (make-rat 6 -9))
#2/3
#-2/3
#-2/3

# 2.2
(define (make-segment s e)
  (cons s e))

(define (start-segment x)
  (car x))

(define (end-segment x)
  (cdr x))

(define (make-point x y)
  (cons x y))

(define (x-point x)
  (car x))

(define (y-point x)
  (cdr x))

(define (midpoint-segment x)
  (define (average a b) (/ (+ a b) 2.0))
  (let ((start (start-segment x))
        (end (end-segment x)))
    (make-point (average (x-point start) (x-point end)) (average (y-point start) (y-point end)))))

(define (print-point p) 
   (newline)
   (display "(")
   (display (x-point p)) 
   (display ",")
   (display (y-point p)) 
   (display ")"))

(print-point (midpoint-segment (make-segment (make-point 2 3) (make-point 10 15))))
# (6.0,9.0)

# 2.3
#基于左下右上的两个点确定矩形
(define (make-segment s e)
  (cons s e))

(define (start-segment x)
  (car x))

(define (end-segment x)
  (cdr x))

(define (make-point x y)
  (cons x y))

(define (x-point x)
  (car x))

(define (y-point x)
  (cdr x))

(define (midpoint-segment x)
  (define (average a b) (/ (+ a b) 2.0))
  (let ((start (start-segment x))
        (end (end-segment x)))
    (make-point (average (x-point start) (x-point end)) (average (y-point start) (y-point end)))))

(define (print-point p) 
   (newline)
   (display "(")
   (display (x-point p)) 
   (display ",")
   (display (y-point p)) 
   (display ")"))

(define (compute-perimeter x)
  (let ((left-bottom-point (start-segment x))
        (right-top-point (end-segment x)))
        (* 2 (+ (- (y-point left-bottom-point) (y-point right-top-point)) (- (x-point left-bottom-point) (x-point right-top-point))))))

(compute-perimeter (make-segment (make-point 10 15) (make-point 2 3)))
#40

# 2.4
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
(define (cdr z)
  (z (lambda (p q) q)))

(cdr (cons -5 3))
#3

# 2.5
# 请证明可以只用数和算术运算表示非负整数的序对,方法是把a和b的序对表示为2^a和3^b的乘积。
# 根据基本算术定理,每个正整数都可以被分解为唯一的素数相乘序列,我们可以利用这一点,通过分解cons计算出的整数的序列,从而复原car和cdr
# 举个例子,72可以分解成72=2^3∗3^2=2∗2∗2∗3∗3,要取出car,我们就不断地进行除二操作,每次除二进行一次计数,直到不能除尽为止

(define (expt x y)
  (define (iter r n)
    (if (= n 0)
      r
      (iter (* x r) (- n 1))))
  (iter 1 y))

(define (car z)
  (if (= 0 (remainder z 2))
    (+ 1 (car (/ z 2)))
    0))

(define (cdr z)
  (if (= 0 (remainder z 3))
    (+ 1 (cdr (/ z 3)))
    0))

(define (cons a b)
  (* (expt 2 a) (expt 3 b)))

(car (cons 3 2))
(cdr (cons 3 2))
#3
#2

# 2.6
# 这道题需要将函数具象才能更好理解,建议看此教程:https://boxnos.hatenablog.com/entry/20070723/1186253252
(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))
(define (add-1 n)
  (lambda (f)
    (lambda (x)
      (f ((n f) x)))))

# 2.7
(define (add-iterval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(add-iterval (cons 6.12 7.48) (cons 5.2 4.3))
#(10.42 . 12.68)

# 2.8
#区间之差不能只用上界-上界,下界-下界,例如(1, 3) (3, 4)采用上-上,下-下会变成(2, 1)
(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))

(sub-interval (cons 2 7) (cons 8 3))
#(-6 . 4)

# 2.9
#该题查看http://community.schemewiki.org/?sicp-ex-2.9的解释

# 2.10
(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                  (max p1 p2 p3 p4))))

(define (div-interval x y)
  (if (>= 0 (* (lower-bound y) (upper-bound y)))
      (error "Division error (interval spans 0)" y)
      (mul-interval x (make-interval (/ 1.0 (lower-bound y))
                                     (/ 1.0 (upper-bound y))))))
  

(define i (make-interval 2 7))
(define j (make-interval -1 3))


(mul-interval i j)
(mul-interval j i)
(div-interval i j)
(div-interval j i)
#(-7 . 21)
#(-7 . 21)
#Division error (interval spans 0) (-1 . 3)

# 2.11
# TODO 某些语法还未学到,学习后再做

# 2.12
(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(define (make-center-percent c p)
  (let ((width (* c (/ p 100))))
    (make-interval (- c width) (+ c width))))

(define (percent i)
  (let ((center (/ (+ (upper-bound i) (lower-bound i)) 2.0))
       (width (/ (- (upper-bound i) (lower-bound i)) 2.0)))
       (* (/ width center) 100)))

(define (center x)
  (/ (+ (car x) (cdr x)) 2))

(make-center-percent (center (cons 5 10)) 20)
#(6 . 9)
(percent (make-interval 10 50))
#66.66666666666666

# 2.13
# a的区间可以表示为:(Ca表示a的中点, Ta表示a的误差)
# a = [Ca*(1 - 0.5*Ta), Ca*(1 + 0.5*Ta)]
# b的区间可以表示为:(Cb表示a的中点, Tb表示b的误差)
# b = [Cb*(1 - 0.5*Tb), Cb*(1 + 0.5*Tb)]
# a*b:
a*b = [Ca*(1 - 0.5*Ta)*Cb*(1 - 0.5*Tb), Ca*(1 + 0.5*Ta)*Cb*(1 + 0.5*Tb)]
    = [Ca*Cb*(1 - 0.5*(Ta+Tb) + 0.25TaTb), Ca*Cb*(1 + 0.5*(Ta+Tb) + 0.25TaTb)]
# Ta*Tb*0.25数值较小,可以忽略

# 2.14
#本题考查的是变量相互独立的问题,(mul-interval x y)
#函数在求解最大和最小边界时导致x和y两个区间不再互相独立,所以会导致错误结果
(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(define (mul-interval x y)
  (let ((p1 (* (lower-bound x) (lower-bound y)))
        (p2 (* (lower-bound x) (upper-bound y)))
        (p3 (* (upper-bound x) (lower-bound y)))
        (p4 (* (upper-bound x) (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                  (max p1 p2 p3 p4))))

(define (div-interval x y)
  (if (>= 0 (* (lower-bound y) (upper-bound y)))
      (error "Division error (interval spans 0)" y)
      (mul-interval x (make-interval (/ 1.0 (lower-bound y))
                                     (/ 1.0 (upper-bound y))))))

(define (add-interval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(define (par1 r1 r2)
  (div-interval (mul-interval r1 r2)
                (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval one (add-interval (div-interval one r1)
                                    (div-interval one r2)))))

(par1 (make-interval 3 7) (make-interval 4 6))
(par2 (make-interval 3 7) (make-interval 4 6))
#(0.9230769230769231 . 6.0)
#(1.7142857142857144 . 3.230769230769231)

# 2.15
# 说法正确,one和r1,r2互相独立

# 2.16
#代数表达式等价的前提是变量相互独立,不独立时无法保证结果的准确;
#设计新的算术包,需要从(mul-interval x y)函数下手

# 2.17
(define (last-pairs l)
  (if (null? (cdr l))
    l
    (last-pairs (cdr l))))

(last-pairs (list 23 72 149 34))
#(34)

# 2.18
(define (reverse list1)
  (define (reverse-iter listf listb)
    (if (null? listb)
        listf
        (reverse-iter (cons (car listb) listf) (cdr listb))))
  (reverse-iter (list (car list1)) (cdr list1)))

(reverse (list 1 4 9 16 25))
#(25 16 9 4 1)

# 2.19
(define us-coins (list 50 25 10 5 1))
(define uk-coins (list 100 50 20 10 5 2 1 0.5))

(define (no-more? c)
  (null? c))

(define (except-first-denomination c)
  (cdr c))

(define (first-denomination c)
  (car c))

(define (cc amount coin-values)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (no-more? coin-values)) 0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount
                   (first-denomination coin-values))
                coin-values)))))

(cc 100 us-coins)
#292

# 2.20
(define (append list1 list2)
  (if (null? list1)
    list2
    (cons (car list1) (append (cdr list1) list2))))

(define (same-parity a . y)
  (let ((prop (remainder a 2)))
    (define (iter target items)
      (if (null? items)
          target
          (if (= (remainder (car items) 2) prop)
              (iter (append target (list (car items))) (cdr items))
           (iter target (cdr items)))))
    (append (list a) (iter (list) y))))

(same-parity 1 2 3 4 5 6 7)
(same-parity 2 3 4 5 6 7)
#(1 3 5 7)
#(2 4 6)

# 2.21
(define (square-list items)
  (if (null? items)
    nil
    (cons (* (car items) (car items)) (square-list (cdr items)))))

(define (map proc items)
  (if (null? items)
    nil
    (cons (proc (car items)) (map proc (cdr items)))))

(define (square-list items)
  (map (lambda (x) (* x x)) items))

# 2.22
#以下代码的顺序写反了
(cons (square (car things))
  answer)

#修改后的程序实现了顺序正确的功能,但是因为第一位是nil,导致第一位元素始终为空
#((((() . 1) . 9) . 25) . 49)

# 2.23
(for-each (lambda (x) (newline) (display x))
  (list 57 321 88))

(define (for-each proc items)
  (if (null? items)
    #t
    (and (proc (car items)) (for-each proc (cdr items)))))

# 2.24

      (1 (2 (3 4)))
      /         \
      1            2
                /  \
              3     4

# 2.25
(car (cdr (car (cdr (cdr (list 1 3 (list 5 7) 9))))))
(car (car (list (list 7))))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7))))))))))))))))))

# 2.26
(define (append list1 list2)
  (if (null? list1)
    list2
    (cons (car list1) (append (cdr list1) list2))))

(define x (list 1 2 3))
(define y (list 4 5 6))
(append x y)
(cons x y)
(list x y)
#(1 2 3 4 5 6)
#((1 2 3) 4 5 6)
#((1 2 3) (4 5 6))

# 2.27
# TODO温习这道题,递归还是不太会
(define (reverse items)
  (define (rev-imp items result)
    (if (null? items)
      result
      (rev-imp (cdr items) (cons (car items) result))))
  (rev-imp items nil))


(define (deep-reverse items)
  (define (rev-imp items result)
    (if (null? items)
        result
        (let ((first (car items)))
          (rev-imp (cdr items) (cons (if (pair? first)
                                         (deep-reverse first)
                                         first)
                                     result)))))
  (rev-imp items nil))

(reverse (list 2 3 4 5))
(deep-reverse (list (list 1 2) (list 3 4)))

# 2.28
(define x (list (list 1 2) (list 3 4)))

(define (frigne items)
  (define (dis-leaves items result)
    (cond ((null? items) result)
      ((pair? items) (dis-leaves (car items) (dis-leaves (cdr items) result)))
      (else (cons items result))))
  (dis-leaves items nil))

(frigne x)
(frigne (list x x))
#(1 2 3 4)
#(1 2 3 4 1 2 3 4)

# 2.29
a)
(define (make-mobile left right)
  (list left right))

(define (make-branch length structure)
  (list length structure))

(define (left-branch movable)
  (car movable))

(define (right-branch movable)
  (car (cdr movable)))

(define l (make-branch 2 5))
(define r (make-branch 3 4))
(define b (make-mobile l r))
(left-branch b)
(right-branch b)
#(2 5)
#(3 4)

b)
# 计算总重量时需要将构造函数"make-mobile"和"make-branch"由list改为cons,因为list选择右侧分支时必要要用(cdr (cdr
(define (make-mobile left right)
  (cons left right))

(define (make-branch length structure)
  (cons length structure))

(define (left-branch movable)
  (car movable))

(define (right-branch movable)
  (cdr movable))

(define (total-weight movable)
  (cond ((null? movable) 0)
    ((not (pair? movable)) movable)
    (else (+ 
           (total-weight (cdr (left-branch movable)))
           (total-weight (cdr (right-branch movable)))))))

(define l (make-branch 2 5))
(define r (make-branch 3 4))
(define b (make-mobile l r))

(left-branch b)
(right-branch b)
(total-weight b)

c)
(define (branch-length branch)
  (car branch))

(define (branch-structure branch)
  (cdr branch))

(define (torque branch)
  (* (branch-length branch) (total-weight (branch-structure branch))))

(define (balanced? mobile)
  (if (not (pair? mobile))
      true
      (and (= (torque (left-branch mobile)) (torque (right-branch mobile)))
           (balanced? (branch-structure (left-branch mobile)))
           (balanced? (branch-structure (right-branch mobile))))))

# 2.30
(define (square-list items)
  (cond ((null? items) nil)
        ((not (pair? items)) (* items items))
        (else (cons (square-list (car items))
                    (square-list (cdr items))))))

(define (map-square-list items)
  (map (lambda (sub-items)
         (if (pair? sub-items)
             (map-square-list sub-items)
             (* sub-items sub-items)))
       items))

(define x (list 1 (list 2 (list 3 4) 5) (list 6 7)))

(square-list x)
(map-square-list x)
#(1 (4 (9 16) 25) (36 49))
#(1 (4 (9 16) 25) (36 49))

# 2.31
(define (tree-map proc tree)
  (map (lambda (sub-items)
         (if (pair? sub-items)
             (tree-map proc sub-items)
             (proc sub-items)))
       tree))

(define (square x)
  (* x x))

(define (square-tree tree)
  (tree-map square tree))

(define x (list 1 (list 2 (list 3 4) 5) (list 6 7)))
(square-tree x)

# 2.32
(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x) (car (cons s x))) rest)))))

(subsets (list 1 2 3))

# 2.33
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) nil sequence))

(define (square x)
  (* x x))

(map square (list 1 2 3 4))
#(1 4 9 16)

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (append seq1 seq2)
  (accumulate cons seq2 seq1))

(append (list 1 2 3) (list 9 8 7))
#(1 2 3 9 8 7)

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (length sequence)
  (accumulate (lambda (x y) (+ y 1)) 0 sequence))

(length (list 1 0 0 2 2 3))
#6

# 2.34
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff highter-terms) (+ this-coeff (* x highter-terms)))
              0
              coefficient-sequence))

(horner-eval 2 (list 1 3 0 5 0 1))
#79

# 2.35
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (count-leaves t)
  (accumulate + 0 (map
                   (lambda (t) (cond ((null? t) 0)
                                      ((pair? t) (count-leaves t))
                                      (else 1))) t)))

(count-leaves '(3 2  () 1))
#3

# 2.36
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

(accumulate-n + 0 '((1 2 3) (4 5 6) (7 8 9) (10 11 12)))
#(22 26 30)

# 2.37
(define (dot-product v w)
  (accumulate + 0 (map * v w)))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(dot-product (list 1 2 3) (list 4 5 6))
#32

(define (matrix-*-vector m v)
  (map (lambda (x) (dot-product x v)) m))

(define matrix (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12)))
(matrix-*-vector matrix (list 2 3 4 5))
#(40 96 152)

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

(define (transpose mat)
  (accumulate-n cons nil mat))

(transpose matrix)
#((1 5 9) (2 6 10) (3 7 11) (4 8 12))

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (dot-product v w)
  (accumulate + 0 (map * v w)))

(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init (map car seqs))
            (accumulate-n op init (map cdr seqs)))))

(define (matrix-*-vector m v)
  (map (lambda (x) (dot-product x v)) m))

(define (transpose mat)
  (accumulate-n cons nil mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (x) (matrix-*-vector cols x)) m)))

(define matrix (list (list 1 2 3 4) (list 5 6 7 8) (list 9 10 11 12)))
(matrix-*-matrix matrix (list (list 1 2) (list 1 2) (list 1 2) (list 1 2))) 
#((10 20) (26 52) (42 84))

# 2.38
(define (fold-right op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (fold-right op initial (cdr sequence)))))

(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))

(fold-right / 1 (list 1 2 3))
(fold-left / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left list nil (list 1 2 3))
#3/2
#1/6
#(1 (2 (3 ())))
#(((() 1) 2) 3)
#op需要满足的条件是交换律和结合律

# 2.39
(define (fold-right op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (fold-right op initial (cdr sequence)))))

(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))

(define (reverse-right sequence)
  (fold-right (lambda (x y) (append y (list x))) nil sequence))

(define (reverse-left sequence)
  (fold-left (lambda (x y) (append (list y) x)) nil sequence))

(reverse-right (list 1 2 3 4 5))
(reverse-left (list 1 2 3 4 5))
#(5 4 3 2 1)
#(5 4 3 2 1)

# 2.40
(define (filter predicate sequence) 
   (cond ((null? sequence) nil) 
         ((predicate (car sequence)) 
          (cons (car sequence)  
                (filter predicate (cdr sequence)))) 
         (else (filter predicate (cdr sequence))))) 

(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(define (enumerate-interval low high)
  (if (> low high)
      nil
      (cons low (enumerate-interval (+ low 1) high))))

(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))

 (define (prime? x) 
   (define (test divisor) 
     (cond ((> (* divisor divisor) x) true) 
           ((= 0 (remainder x divisor)) false) 
           (else (test (+ divisor 1))))) 
   (test 2))

(define (prime-sum? pair) 
   (prime? (+ (car pair) (cadr pair))))

(define (make-pair-sum pair) 
   (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum?
               (flatmap
                (lambda (i)
                  (map (lambda (j) (list i j))
                       (enumerate-interval 1 (- i 1))))
                (enumerate-interval 1 n)))))

(define (unique-pairs n) 
   (flatmap (lambda (i)  
              (map (lambda (j) (list i j)) 
                   (enumerate-interval 1 (- i 1)))) 
            (enumerate-interval 1 n)))

(define (prime-sum-pairs-new n) 
   (map make-pair-sum 
        (filter prime-sum? (unique-pairs n)))) 

(prime-sum-pairs 6)
(prime-sum-pairs-new 6)
#((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11))
#((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11))
