:PROPERTIES:
:ID:       cd78ab75-eda6-42ae-a613-54a7834e7a4c
:END:
#+title: sicp-test
#+LANGUAGE: zh-CN
#+OPTIONS: toc:2 num:3 H:4 ^:nil pri:t
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://gongzhitaao.org/orgcss/org.css">
#+EXPORT_FILE_NAME: ~/Dropbox/export/sicp_test.org

# scheme version: racket 8.10-1
# use DrRacket IDE install sicp package.Detils https://docs.racket-lang.org/sicp-manual/Installation.html
# reference: https://sicp-solutions.net/;http://community.schemewiki.org/?sicp-solutions

# 1.1
10,12,8,3,6,,,19,#f,4,16,6,16

# 1.2
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

# 1.3
(define (square x) (* x x))
(define (squareSum x y) (+ (square x) (square y)))
(define (sumSquareLargestTwo x y z)
    (cond ((and (>= (+ x y) (+ y z)) (>= (+ x y) (+ x z))) (squareSum x y))
        ((and (>= (+ x y) (+ y z)) (>= (+ x z) (+ y z))) (squareSum x z))
        (else (squareSum y z))))

# 1.4
a+|b|

# 1.5
应用序先求值再应用,所以会使用重复(test 0 (p)),正则序使用形参替代先完全展开再计算结果,所以会得出正确结果0

# 1.6
由于新的new-if不再是特殊形式,即if原本满足条件时仅计算一个参数,但现在采用应用序的方式会计算两个参数,而第二个参数包括递归调用,所以会出现堆栈溢出

# 1.7
对于很大的数,在临界值检测时guess和(improve guess)两值的绝对误差很容易超出容差0.001,因此会陷入无限递归;对于很小的数,guess和(improve guess)两值的绝对误差可能开始就小于容差0.001,导致guess值不会更新.解决办法有:同比例缩放容差,比较guess和(improve guess)的相对值

# 1.8
(define (curt-iter guess x)
    (if (good-enough? guess x)
    guess
    (curt-iter (improve guess x) x)))
(define (improve guess x)
    (/ (+ (/ x (square guess)) (* 2 guess)) 3))
(define (good-enough? guess x)
    (< (abs (- (cube guess) x)) 0.001))
(define (cube x)
    (* x x x))
(define (square x)
    (* x x))

# 1.9
第一种方式：
(+ 4 5)
(inc (+ (dec 3) 5))
(inc (inc (+ (dec 2) 5)))
(inc (inc (inc (+ (dec 1) 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
第二种方式：
(+ 4 5)
(+ (dec 4) (inc 5))
(+ 3 6)
(+ (dec 3) (inc 6))
(+ 2 7)
(+ (dec 2) (inc 7))
(+ 1 8)
(+ (dec 1) (inc 8))
(+ 0 9)
9

# 1.10
1024,65536,65536
(f n)计算的是2n
(g n)计算的是2^n
(h n)计算的是2^(2^(2^..(n times)))

# 1.11
(define (fun n)
    (cond ((< n 3) n)
      (else (+ (fun (- n 1))
               (* 2 (fun (- n 2)))
               (* 3 (fun (- n 3)))))))


(define (fun n)
    (cond ((< n 3) n)
    (else (iter-fun 2 1 0 (- n 2)))))

(define (iter-fun a b c x)
    (cond ((= x 0) a)
    (else (iter-fun (+ a (* 2 b) (* 3 c)) a b (- x 1)))))

# 1.12
(define (pascal x y)
    (if (or (= y 1) (= x y))
    1
    (+ (pascal (- x 1) (- y 1)) (pascal (- x 1) y))))

# 1.13
http://community.schemewiki.org/?sicp-ex-1.13

# 1.14
#n种硬币,金额a
#space: a+n
#step: a^n

# 1.15
#a) 5
#b) log(a) 关于如何计算出Log的可以参考一下http://community.schemewiki.org/?sicp-ex-1.15

# 1.16
(define (fast-expt-iter a b n)
    (cond ((= n 1) a)
    ((even? n)
    (fast-expt-iter (square b) (square b) (/ n 2)))
    (else (* b (fast-expt-iter a b (- n 1))))))

(define (square x)
    (* x x))

# offical
(define (iter-fast-expt b n)
    (define (iter N B A)
        (cond ((= N 0) A)
        ((even? N) (iter (/ N 2) (square B) A))
        (else (iter (- N 1) B (* B A)))))
    (iter n b 1))

# 1.17
(define (double x)
    (+ x x))

(define (halve n)
    (/ n 2))

(define (* a b)
    (cond ((= b 0) 0)
        ((even? b) (double (* a (halve b))))
        (else (+ a (* a (- b 1))))))

# 1.18
(define (fast-mult-iter a b)
    (define (iter a b n)
        (cond ((= a 0) n)
            ((even? a) (iter (/ a 2) (double b) n))
            (else (iter (- a 1) b (+ b n)))))
            (iter a b 0))

# 1.19
# T_pq(a, b) = (bq + aq + ap, bp + aq), T_p'q' = T_pq(T_pq(a, b)) = ((bp + aq)q + (bq + aq + ap)q + (bq + aq + ap)p, (bp + aq)p + (bq + aq + ap)q)
# T_p'q' = (b(2qp + q^2) + a(2qp + q^2) + a(q^2 + p^2), b(p^2 + q^2) + a(2qp + q^2))
# p' = p^2 + q^2; q' = 2qp + q^2

# 1.20
# (define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))
# 正则序和应用序的区别,正则序先代换用到时才求值,应用序先求值再代换

# 正则序过程
(gcd 206 40)

(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))

(gcd 40 (remainder 206 40))

(if (= (remainder 206 40) 0)    # 此处第一次需要用到(remainder 206 40)的结果进行判断,其结果为6
    40
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))

(if (= 6 0)
    40
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))

(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))

(if (= (remainder 40 (remainder 206 40)) 0)     # 第二次计算(remainder 206 40)
    (remainder 206 40)
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))

(if (= (remainder 40 6) 0)     # 第三次计算(remainder 40 6)
    (remainder 206 40)
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))
    ...
共计18 times

# 应用序过程
(gcd 206 40)
(gcd 206 (gcd 40 6))
(gcd 206 (gcd 40 (gcd 6 4)))
(gcd 206 (gcd 40 (gcd 6 (gcd 4 2))))
(gcd 206 (gcd 40 (gcd 6 (gcd 4 (gcd 2 0)))))
4 times;

# 1.21
(define (smallest-divisor n)
    (find-divisor n 2))

(define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
    (= (remainder a b) 0))

(define (square a)
    (* a a))

(smallest-divisor 199)
# 199
(smallest-divisor 1999)
# 1999
(smallest-divisor 19999)
# 19999

# 1.22
(define (smallest-divisor n)
    (find-divisor n 2))

(define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
    (= (remainder a b) 0))

(define (square a)
    (* a a))

(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (prime? n)
    (= (smallest-divisor n) n))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(search-for-primes 1000 1090)
#1001 *** 3
#1003 *** 2
#1005 *** 2
(search-for-primes 10000 10090)
#10001 *** 6
#10003 *** 4
#10005 *** 3
(search-for-primes 100000 100090)
#100001 *** 10
#100003 *** 9
#100005 *** 9
(search-for-primes 1000000 100090)
#1000001 *** 35
#1000003 *** 38
#1000005 *** 32

# 1.23
(define (next n)
    (if (= n 2) 3)
        (+ n 2))

(define (smallest-divisor n)
    (find-divisor n 2))

(define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
        ((divides? (next test-divisor) n) test-divisor)
        (else (find-divisor n (next test-divisor)))))

(define (divides? a b)
    (= (remainder a b) 0))

(define (square a)
    (* a a))

(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (prime? n)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (prime? n)
    (= (smallest-divisor n) n))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(search-for-primes 1000 1090)
#1001 *** 4
#1003 *** 1
#1005 *** 1
(search-for-primes 10000 10090)
#10001 *** 6
#10003 *** 4
#10005 *** 3
(search-for-primes 100000 100090)
#100001 *** 10
#100003 *** 9
#100005 *** 8
(search-for-primes 1000000 1000090)
#1000001 *** 37
#1000003 *** 39
#1000005 *** 26

# 1.24
(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (fast-prime? n 100)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else #f)))

(define (expmod base exp m)
    (cond ((= exp 0) 1)
        ((even? exp)
        (remainder (square (expmod base (/ exp 2) m))
            m))
        (else
            (remainder (* base (expmod base (- exp 1) m))
            m))))

(define (square n)
    (* n n))

(search-for-primes 1000 1090)
#1009 *** 85
#1013 *** 79
(search-for-primes 10000 10090)
#10007 *** 84
#10009 *** 89
(search-for-primes 100000 100090)
#100003 *** 116
(search-for-primes 1000000 1000090)
#1000003 *** 121
#1000033 *** 135

# 1.25
(define (timed-prime-test n)
    (newline)
    (display n)
    (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
    (if (fast-prime? n 100)
        (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
    (display " *** ")
    (display elapsed-time))

(define (search-for-primes start-range end-range)
    (if (even? start-range)
        (search-for-primes (+ start-range 1) end-range)
        (cond ((> start-range end-range)
            (newline) (display "Done"))
            (else (timed-prime-test start-range)
                (search-for-primes (+ start-range 2) end-range)))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else #f)))

(define (expmod base exp m)
    (remainder (fast-expt-iter 1 base exp) m))

(define (square n)
    (* n n))

(define (fast-expt-iter a b n)
    (cond ((= n 1) a)
    ((even? n)
    (fast-expt-iter (square b) (square b) (/ n 2)))
    (else (* b (fast-expt-iter a b (- n 1))))))

(search-for-primes 1000 1090)
#1009 *** 18253

# 简单理解,求出的幂值已经超出2^63次方,所以需要使用软件进行计算,其计算速度远慢于硬件计算

# 1.26
# 由于解释器采用应用序过程,使用显式乘法后,乘法两端的(square (expmod base (/ exp 2) m))需要在应用乘法*之前就要计算出来,由于(square (expmod base (/ exp 2) m))都是递归调用,所以增加了两倍的计算量

# 1.27
# 561 1105 1729 2465 2821 6601
(define (prime-check n)
    (fast-prmie? n 100))

(define (fast-prmie? n times)
    (cond ((= times 0) #t)
        ((fermat-test n) (fast-prmie? n (- times 1)))
        (else #f)))

(define (fermat-test n)
    (define (try-it a)
        (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))

(define (expmod base exp m)
    (cond ((= exp 0) 1)
        ((even? exp) 
            (remainder (square (expmod base (/ exp 2) m)) m))
        (else 
            (remainder (* base (expmod base (- exp 1) m)) m))))

(define (square n)
    (* n n))

(prime-check 561)
#t
(prime-check 1105)
#t
(prime-check 1729)
#t
(prime-check 2465)
#t
(prime-check 2821)
#t
(prime-check 6601)
#t

# 1.28
(define (prime-check n)
    (fast-prmie? n 100))

(define (fast-prmie? n times)
    (cond ((= times 0) #t)
        ((fermat-test n) (fast-prmie? n (- times 1)))
        (else #f)))

(define (fermat-test n)
    (define (try-it a)
        (= (expmod a (- n 1) n) 1))
    (try-it (+ 1 (random (- n 1)))))

(define (check-square-root x m)
    (if (and (not (or (= x 1) (= x (- m 1)))) (= (remainder (* x x) m) 1))
    0)
    (remainder (* x x) m))

(define (expmod base exp m)
    (cond ((= exp 0) 1)
        ((even? exp)
            (check-square-root (expmod base (/ exp 2) m) m))
        (else
            (remainder (* base (expmod base (- exp 1) m)) m))))

(prime-check 2)
#t
(prime-check 1009)
#t
(prime-check 4)
#f
(prime-check 99)
#f
(prime-check 561)
#f

# 1.29
(define (sum term a next b)
  (if (> a b)
      0
      (+ (term a)
         (sum term (next a) next b))))

(define (integral-simpson f a b n)
  (define h (/ (- b a) n))
  (define (simpson-term x)
    (+ (f x) (* 4 (f (+ x h))) (f (+ x h h))))
  (define (simpson-next x)
    (+ x (* 2 h)))
  (* (sum simpson-term a simpson-next (- b (* 2 h))) (/ h 3)))

(define (cube x)
  (* x x x))

(integral-simpson cube 0 1 100)
# 1/4
(integral-simpson cube 0 1 1000)
# 1/4

# 1.30
(define (sum term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))

(define (integral-simpson f a b n)
  (define h (/ (- b a) n))
  (define (simpson-term x)
    (+ (f x) (* 4 (f (+ x h))) (f (+ x h h))))
  (define (simpson-next x)
    (+ x (* 2 h)))
  (* (sum simpson-term a simpson-next (- b (* 2 h))) (/ h 3)))

(define (cube x)
  (* x x x))

(integral-simpson cube 0 1 100)
# 1/4
(integral-simpson cube 0 1 1000)
# 1/4

# 1.31
# recursion
(define (product term a next b)
  (if (> a b)
    1
    (* (term a) (product term (next a) next b))))

(define (pi-term n)
  (if (even? n)
      (/ (+ n 2) (+ n 1))
      (/ (+ n 1) (+ n 2))))

(define (pi-next n)
  (+ n 1))

(* (product pi-term 1 pi-next 100) 4.0)
#3.1570301764551676

# iteration
(define (product term a next b)
  (define (iter a result)
    (if (> a b)
        result
        (iter (next a) (* (term a) result))))
  (iter a 1))

(define (pi-term n)
  (if (even? n)
      (/ (+ n 2) (+ n 1))
      (/ (+ n 1) (+ n 2))))

(define (pi-next n)
  (+ n 1))

(* (product pi-term 1 pi-next 100) 4.0)
#3.1570301764551676

# 1.32
# a) recursion
(define (accumulate combiner null-value term a next b)
  (if (> a b)
    null-value
    (combiner (term a) (accumulate combiner null-value term (next a) next b))))

(define (sum term a next b)
  (accumulate + 0 term a next b))

(define (product term a next b)
  (accumulate * 1 term a next b))

# b) iteration
(define (accumulate combiner null-value term a next b)
  (define (iter a res)
    (if (> a b)
        res
        (iter (next a) (combiner (res (term a))))))
  (iter a null-value))

# 1.33
# a)
# 求出在区间a到b中所有素数的平方和
(define (filtered-accumulate combiner filter null-value term a next b)
  (if (> a b)
    null-value
    (combiner (if (filter a) (term a) null-value) (filtered-accumulate combiner filter null-value term (next a) next b))))

(define (fa-next x)
  (+ x 1))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else #f)))

(define (expmod base exp m)
    (remainder (fast-expt-iter 1 base exp) m))

(define (square n)
    (* n n))

(define (fast-expt-iter a b n)
    (cond ((= n 1) a)
    ((even? n)
    (fast-expt-iter (square b) (square b) (/ n 2)))
    (else (* b (fast-expt-iter a b (- n 1))))))

(define (prime? n)
    (fast-prime? n 10))

(define (sum term a next b)
  (filtered-accumulate + prime? 0 term a next b))

(sum square 2 fa-next 20)
# 1027

# b)
(define (filter-accumulate combiner filter null-value term a next b)
  (if (> a b)
    null-value
    (combiner (if (filter a) (term a) null-value) (filter-accumulate combiner filter null-value term (next a) next b))))

(define (gcd i n)
  (if (= n 0)
    i
    (gcd n (remainder i n))))

(define (gp-term x) x)

(define (gp-next x) 
  (+ x 1))


(define (product-of-relative-prime n)
  (define (relative-prime? i)
    (= (gcd i n) 1))
  (filter-accumulate * relative-prime? 1 gp-term 1 gp-next n))

(product-of-relative-prime 10)
# 189

# 1.34
(f f) -> (f 2),但2不是一个过程

# 1.35
# 黄金分割率    Φ^2 = Φ + 1
x = 1 + 1/x ==>> x^2 = x + 1

(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (phi x)
  (+ 1 (/ 1 x)))

(fixed-point phi 1.0)
# 1.6180371352785146

# 1.36
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (phi x)
  (+ 1 (/ 1 x)))

(fixed-point phi 1.0)
# 1.0
# 2.0
# 1.5
...

# non average damping
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))


(fixed-point (lambda (x) (/ (log 1000) (log x))) 2.0)
# 2.0
# 9.965784284662087
# 3.004472209841214
...totle 35

# average damping
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (display guess)
    (newline)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (average m n)
  (/ (+ m n) 2))


(fixed-point (lambda (x) (average x (/ (log 1000) (log x)))) 2.0)
# 2.0
# 5.9828921423310435
# 4.922168721308343
... totle 210

# 1.37
a)
(define (cont-frac n d k)
  (define (recur i)
    (if (= k i)
        (/ (n i) (d i))
        (/ (n i) (+ (d i) (recur (+ i 1))))))
  (recur 1))

(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           12)

b)
(define (cont-frac n d k)
  (define (iter i result)
    (if (= i 0)
      result
      (iter (- i 1) (/ (n i) (+ (d i) result)))))
  (iter (- k 1) (/ (n k) (d k))))

(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           12)
# 0.6180257510729613

# 1.38
(define (cont-frac n d k)
  (define (recur i)
    (if (= k i)
      (/ (n i) (d i))
      (/ (n i) (+ (d i) (recur (+ i 1))))
      ))
  (recur 1))

(+ 2 (cont-frac (lambda (i) 1.0)
  (lambda (i)
    (if (= (remainder i 3) 2)
        (/ (+ i 1) 1.5)
        1))
  10))

# 1.39
(define (cont-frac n d k)
  (define (recur i)
    (if (= k i)
      (/ (n i) (d i))
      (/ (n i) (+ (d i) (recur (+ i 1))))
      ))
  (recur 1))

(define (tan-cf x k)
  (cont-frac (lambda (i) (if (= i 1) x (* x x -1)))
             (lambda (i) (- (* 2 i) 1))
             k))

(tan-cf 1.0 8)
# 1.557407724654856

# 1.40
(define dx 0.00001)

(define (deriv g)
  (lambda (x) (/ (- (g (+ x dx)) (g x)) dx)))

(define (newton-transform g)
  (lambda (x) (- x (/ (g x) ((deriv g) x)))))

(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
        guess
        (fixed-point f next))))
  (try first-guess))

(define (average m n)
  (/ (+ m n) 2))

(define (newtons-method g guess)
  (fixed-point (newton-transform g) guess))

(define (square x)
  (* x x))

(define (sqrt x)
  (newtons-method (lambda (y) (- (square y) x)) 1.0))

(sqrt 5)

(define (cubic a b c)
  (lambda (x) (+ (* x x x) (* a (* x x)) (* b x) c)))

(define a 1)
(define b 1)
(define c 1)

(newtons-method (cubic a b c) 1)
#2.2360689003143683
#-1.000000022096024

# 1.41
(define (double g)
  (lambda (x) (g (g x))))

(define (inc x)
  (+ x 1))

(((double (double double)) inc) 5)
#21

# 1.42
(define (compose f g)
  (lambda (x) (f (g x))))

(define (square x)
  (* x x))

(define (inc x)
  (+ x 1))

((compose square inc) 6)
#49

# 1.43
(define (square x) (* x x))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (repeated f n)
  (if (= n 1)
      f
      (compose f (repeated f (- n 1)))))

((repeated square 2) 5)
#625

# 1.44
(define (square x) (* x x))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (repeated f n)
  (if (= n 1)
      f
      (compose f (repeated f (- n 1)))))

(define dx 0.00001)

(define (smooth f)
  (lambda (x) (/ (+ (f (- x dx)) (f x) (f (+ x dx))) 3)))

(define (n-fold-smooth f n)
  ((repeated smooth n) f))

((n-fold-smooth square 2) 6)
#36.00000000013333

# 1.45
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (< (abs (- v1 v2)) tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? next guess)
        next
        (try next))))
  (try first-guess))

(define (average-damp f)
  (lambda (x) (average x (f x))))

(define (average n m)
  (/ (+ n m) 2))

(define (repeated f n)
  (if (= n 1)
    f
    (compose f (repeated f (- n 1)))))

(define (compose f g)
  (lambda (x) (f (g x))))

(define (power x n)
  (if (= n 1)
      x
      (* x (power x (- n 1)))))

# 多复习
(define (nth-root-damped x nth)
  (fixed-point 
     ((repeated average-damp (floor (log n 2))) 
       (lambda (y) (/ x (expt y (- n 1))))) 
     1.0))

# 1.46
(define (iterative-improve close-enough? improve)
  (lambda (guess)
    (if (close-enough? guess)
      guess
      ((iterative-improve close-enough? improve) (improve guess)))))

# sqrt
(define (sqrt-iter guess x)
  ((iterative-improve (lambda (g)  (good-enough? g x)) (lambda (g) (improve g x))) guess))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.0001))

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y)
  (/ (+ x y) 2))

(define (square x)
  (* x x))

(sqrt-iter 1.0 9)
#3.000000001396984

# fixed-point
(define tolerance 0.00001)
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
      (< (abs (- v1 v2)) tolerance))
  ((iterative-improve (lambda (x) (close-enough? x (f x))) 
     f) first-guess))

(fixed-point cos  1.0)
#0.7390893414033927

# 2.1
(define (numer x) (car x))
(define (denom x) (cdr x))

(define (make-rat n d)
  (let ((g ((if (< d 0) - +) (gcd n d))))
    (cons (/ n g) (/ d g))))

(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

(print-rat (make-rat 6 9))
(print-rat (make-rat -6 9))
(print-rat (make-rat 6 -9))
#2/3
#-2/3
#-2/3

# 2.2
(define (make-segment s e)
  (cons s e))

(define (start-segment x)
  (car x))

(define (end-segment x)
  (cdr x))

(define (make-point x y)
  (cons x y))

(define (x-point x)
  (car x))

(define (y-point x)
  (cdr x))

(define (midpoint-segment x)
  (define (average a b) (/ (+ a b) 2.0))
  (let ((start (start-segment x))
        (end (end-segment x)))
    (make-point (average (x-point start) (x-point end)) (average (y-point start) (y-point end)))))

(define (print-point p) 
   (newline)
   (display "(")
   (display (x-point p)) 
   (display ",")
   (display (y-point p)) 
   (display ")"))

(print-point (midpoint-segment (make-segment (make-point 2 3) (make-point 10 15))))
# (6.0,9.0)

# 2.3
#基于左下右上的两个点确定矩形
(define (make-segment s e)
  (cons s e))

(define (start-segment x)
  (car x))

(define (end-segment x)
  (cdr x))

(define (make-point x y)
  (cons x y))

(define (x-point x)
  (car x))

(define (y-point x)
  (cdr x))

(define (midpoint-segment x)
  (define (average a b) (/ (+ a b) 2.0))
  (let ((start (start-segment x))
        (end (end-segment x)))
    (make-point (average (x-point start) (x-point end)) (average (y-point start) (y-point end)))))

(define (print-point p) 
   (newline)
   (display "(")
   (display (x-point p)) 
   (display ",")
   (display (y-point p)) 
   (display ")"))

(define (compute-perimeter x)
  (let ((left-bottom-point (start-segment x))
        (right-top-point (end-segment x)))
        (* 2 (+ (- (y-point left-bottom-point) (y-point right-top-point)) (- (x-point left-bottom-point) (x-point right-top-point))))))

(compute-perimeter (make-segment (make-point 10 15) (make-point 2 3)))
#40

# 2.4
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
(define (cdr z)
  (z (lambda (p q) q)))

(cdr (cons -5 3))
#3

# 2.5
# 请证明可以只用数和算术运算表示非负整数的序对,方法是把a和b的序对表示为2^a和3^b的乘积。
# 根据基本算术定理,每个正整数都可以被分解为唯一的素数相乘序列,我们可以利用这一点,通过分解cons计算出的整数的序列,从而复原car和cdr
# 举个例子,72可以分解成72=2^3∗3^2=2∗2∗2∗3∗3,要取出car,我们就不断地进行除二操作,每次除二进行一次计数,直到不能除尽为止

(define (expt x y)
  (define (iter r n)
    (if (= n 0)
      r
      (iter (* x r) (- n 1))))
  (iter 1 y))

(define (car z)
  (if (= 0 (remainder z 2))
    (+ 1 (car (/ z 2)))
    0))

(define (cdr z)
  (if (= 0 (remainder z 3))
    (+ 1 (cdr (/ z 3)))
    0))

(define (cons a b)
  (* (expt 2 a) (expt 3 b)))

(car (cons 3 2))
(cdr (cons 3 2))
#3
#2

# 2.6
# 这道题需要将函数具象才能更好理解,建议看此教程:https://boxnos.hatenablog.com/entry/20070723/1186253252
(define one (lambda (f) (lambda (x) (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))
(define (add-1 n)
  (lambda (f)
    (lambda (x)
      (f ((n f) x)))))

# 2.7
(define (add-iterval x y)
  (make-interval (+ (lower-bound x) (lower-bound y))
                 (+ (upper-bound x) (upper-bound y))))

(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(add-iterval (cons 6.12 7.48) (cons 5.2 4.3))
#(10.42 . 12.68)

# 2.8
#区间之差不能只用上界-上界,下界-下界,例如(1, 3) (3, 4)采用上-上,下-下会变成(2, 1)
(define (make-interval a b)
  (cons a b))

(define (upper-bound x)
  (max (car x) (cdr x)))

(define (lower-bound x)
  (min (car x) (cdr x)))

(define (sub-interval x y)
  (make-interval (- (lower-bound x) (upper-bound y))
                 (- (upper-bound x) (lower-bound y))))

(sub-interval (cons 2 7) (cons 8 3))
#(-6 . 4)
